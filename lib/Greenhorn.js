// Generated by CoffeeScript 1.8.0

/*
environment.coffee
Written by Seth Bullock
sedabull@gmail.com
 */

(function() {
  var AniCycle, AniSprite, AudioContext, EventEmitter, Greenhorn, KEYS, Sound, Sprite, TextSprite, Timer, env, _audioContext, _masterID, _masterUpdate, _mixin, _ref,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  this.gh = Object.create(null);

  env = {
    FRAME_RATE: 25,
    BOUNCE_DECAY: 0,
    SPRING_CONSTANT: 25,
    ENGINE: {
      footer: 'FOOTER',
      leftHeader: 'LEFT PANEL',
      rightHeader: 'RIGHT PANEL'
    },
    STARTUP: {
      size: 50,
      color: '#006400',
      font: 'sans-serif',
      text: 'Click here to Start'
    },
    IMAGE_PATH: "./",
    SPRITE_DEFAULT_CONFIG: {
      x: 0,
      y: 0,
      a: 0,
      dx: 0,
      dy: 0,
      da: 0,
      ddx: 0,
      ddy: 0,
      dda: 0,
      level: 0,
      scale: 1,
      width: 64,
      height: 64,
      visible: true,
      imageFile: '',
      shape: 'polygon',
      highlight: false,
      ba_top: 'WRAP',
      ba_bottom: 'WRAP',
      ba_right: 'WRAP',
      ba_left: 'WRAP'
    },
    TEXTSPRITE_DEFAULT_CONFIG: {
      level: -1,
      text: "*-TEXTSPRITE-*",
      fontSize: 12,
      fontAlpha: 1.0,
      fontColor: "white",
      fontAlign: "left",
      fontName: "sans-serif",
      borderSize: 5,
      borderAlpha: 1.0,
      borderVisible: true,
      borderColor: "white",
      outlineSize: 1,
      outlineAlpha: 1.0,
      outlineVisible: false,
      outlineColor: "grey",
      marginsTop: 5,
      marginsBottom: 5,
      marginsRight: 5,
      marginsLeft: 5,
      backgroundAlpha: 1.0,
      backgroundVisible: true,
      backgroundColor: "black"
    },
    ANICYCLE_DEFAULT_CONFIG: {
      index: 1,
      start: 1,
      numFrames: 8,
      name: 'UNDEFINED'
    },
    ANISPRITE_DEFAULT_CONFIG: {
      cellWidth: 32,
      cellHeight: 32,
      frameRate: 10,
      orientation: 'horizontal'
    },
    SOUND_PATH: "./",
    USE_AUDIO_TAG: false,
    SOUND_DEFAULT_CONFIG: {
      url: "",
      loop: false,
      volume: 1.0,
      autoplay: false
    },
    BUTTON_DEFAULT_CONFIG: {
      type: 'button',
      onclick: void 0,
      parent: 'rightPanel',
      label: 'Launch the Missiles!'
    },
    TIMER_START_ON_CONSTRUCTION: true
  };

  gh.env = env;


  /*
  eventEmitter.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  EventEmitter = (function() {
    function EventEmitter() {}

    EventEmitter.prototype.on = function(event, listener, options) {
      var key, value;
      if (options == null) {
        options = {};
      }
      if (this._events == null) {
        this._events = {};
      }
      if (!this._events[event]) {
        this.emit('event:added', event);
        this._events[event] = [];
      }
      this.emit('listener:added', event, listener);
      this._events[event].push(listener);
      for (key in options) {
        if (!__hasProp.call(options, key)) continue;
        value = options[key];
        this._events[event][key] = value;
      }
      return this;
    };

    EventEmitter.prototype.once = function(event, listener, options) {
      if (options == null) {
        options = {};
      }
      listener.once = true;
      return this.on(event, listener, options);
    };

    EventEmitter.prototype.emit = function() {
      var args, event, i, listener, _i, _len, _ref;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this._events == null) {
        this._events = {};
      }
      if (this._events[event] != null) {
        _ref = this._events[event];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          listener = _ref[_i];
          listener.apply(this, args);
          if (listener.once != null) {
            i = this._events[event].indexOf(listener);
            this._events[event].splice(i, 1);
            if (this._events[event].length === 0) {
              delete this._events[event];
            }
          }
        }
        return true;
      }
      return false;
    };

    EventEmitter.prototype.remove = function(event, listener) {
      var cb, i, _i, _len, _ref;
      if (this._events == null) {
        this._events = {};
      }
      if (this._events[event] != null) {
        if (listener != null) {
          _ref = this._events[event];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            cb = _ref[i];
            if (!(cb === listener)) {
              continue;
            }
            this.emit('listener:removed', event, listener);
            this._events[event].splice(i, 1);
            if (this._events[event].length === 0) {
              this.emit('event:removed', event);
              delete this._events[event];
            }
          }
        } else {
          this.emit('event:removed', event);
          delete this._events[event];
        }
      }
      return this;
    };

    EventEmitter.prototype.listeners = function(event) {
      if (event != null) {
        return this._events[event];
      } else {
        return this._events != null ? this._events : this._events = {};
      }
    };

    return EventEmitter;

  })();

  _mixin = function(dest, source) {
    var key, value;
    for (key in source) {
      if (!__hasProp.call(source, key)) continue;
      value = source[key];
      dest[key] = value;
    }
    return dest;
  };


  /*
  greenhorn.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  KEYS = {
    ESC: 27,
    SPACE: 32,
    PGUP: 33,
    PGDOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    '0': 48,
    '1': 49,
    '2': 50,
    '3': 51,
    '4': 52,
    '5': 53,
    '6': 54,
    '7': 55,
    '8': 56,
    '9': 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90
  };

  gh.KEYS = KEYS;

  document.onreadystatechange = function() {
    var _ref;
    if (this.readyState === 'interactive') {
      return ((_ref = gh.init) != null ? _ref : Greenhorn.start)();
    }
  };

  document.onkeydown = function(e) {
    e.preventDefault();
    return Greenhorn.isDown[e.keyCode] = true;
  };

  document.onkeyup = function(e) {
    e.preventDefault();
    return Greenhorn.isDown[e.keyCode] = false;
  };

  _masterID = null;

  _masterUpdate = function() {
    Greenhorn.clear();
    if (typeof gh.update === "function") {
      gh.update();
    }
    return Sprite._drawAll();
  };

  Greenhorn = (function() {
    var key, _elmnts, _firstTime, _i, _len, _ref, _startEverything;

    function Greenhorn() {}

    Greenhorn.isDown = new Array(256);

    _ref = Greenhorn.isDown;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      key = false;
    }

    Greenhorn.currentState = 'STARTUP';

    _elmnts = {
      main: document.createElement('div'),
      title: document.createElement('h1'),
      leftPanel: document.createElement('div'),
      leftPanelHeader: document.createElement('h3'),
      canvas: document.createElement('canvas'),
      rightPanel: document.createElement('div'),
      rightPanelHeader: document.createElement('h3'),
      footer: document.createElement('div')
    };

    _elmnts.main.id = 'gh-main';

    _elmnts.title.id = 'gh-title';

    _elmnts.leftPanel.id = 'gh-left-panel';

    _elmnts.canvas.id = 'gh-canvas';

    _elmnts.rightPanel.id = 'gh-right-panel';

    _elmnts.footer.id = 'gh-footer';

    _elmnts.leftPanelHeader.classList.add('gh-h');

    _elmnts.rightPanelHeader.classList.add('gh-h');

    _elmnts.main.appendChild(_elmnts.title);

    _elmnts.main.appendChild(_elmnts.leftPanel);

    _elmnts.main.appendChild(_elmnts.canvas);

    _elmnts.main.appendChild(_elmnts.rightPanel);

    _elmnts.main.appendChild(_elmnts.footer);

    _elmnts.leftPanel.appendChild(_elmnts.leftPanelHeader);

    _elmnts.rightPanel.appendChild(_elmnts.rightPanelHeader);

    _elmnts.canvas.onmousemove = function(e) {
      this.mouseX = e.pageX;
      this.mouseY = e.pageY;
      return Sprite.emitAll('mouse:move');
    };

    _elmnts.canvas.onmousedown = function(e) {
      return Sprite.emitAll('mouse:down');
    };

    _elmnts.canvas.onmouseup = function(e) {
      return Sprite.emitAll('mouse:up');
    };

    _elmnts.canvas.ondblclick = function(e) {
      return Sprite.emitAll('mouse:doubleClick');
    };

    _elmnts.canvas.oncontextmenu = function(e) {
      e.preventDefault();
      return Sprite.emitAll('mouse:rightClick');
    };

    _startEverything = function() {
      _masterID = setInterval(_masterUpdate, 1000 / env.FRAME_RATE);
      Sprite._startAll();
      Sound._playAll();
    };

    Greenhorn.getMouseX = function() {
      return _elmnts.canvas.mouseX - _elmnts.canvas.offsetLeft - _elmnts.canvas.width / 2;
    };

    Greenhorn.getMouseY = function() {
      return -(_elmnts.canvas.mouseY - _elmnts.canvas.offsetTop - _elmnts.canvas.height / 2);
    };

    Greenhorn.addButton = function(config) {
      var button, value, _ref1;
      if (config == null) {
        config = {};
      }
      _ref1 = env.BUTTON_DEFAULT_CONFIG;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        value = _ref1[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      button = document.createElement('button');
      button.type = config.type;
      button.innerHTML = config.label;
      button.onclick = config.onclick;
      button.classList.add('gh-button');
      return _elmnts[config.parent].appendChild(button);
    };

    Greenhorn.changeState = function(stateName) {
      this.emit("state-change-from:" + this.currentState);
      this.emit('state-change', this.currentState, stateName);
      this.emit("state-change-to:" + stateName);
      return this.currentState = stateName;
    };

    _firstTime = true;

    Greenhorn.isRunning = function() {
      return _masterID != null;
    };

    Greenhorn.stop = function() {
      Sprite._stopAll();
      Sound._pauseAll();
      clearInterval(_masterID);
      return _masterID = null;
    };

    Greenhorn.clear = function() {
      return _elmnts.canvas.getContext('2d').clearRect(-_elmnts.canvas.width / 2, -_elmnts.canvas.height / 2, _elmnts.canvas.width, _elmnts.canvas.height);
    };

    Greenhorn.start = function(stateName) {
      var mainDiv, _ctx;
      if (!Greenhorn.isRunning()) {
        if (_firstTime) {
          mainDiv = document.querySelector('#gh');
          if (mainDiv != null) {
            mainDiv.appendChild(_elmnts.main);
          } else {
            console.log("There is no '#gh' element!");
          }
          _elmnts.title.innerHTML = document.title;
          _elmnts.leftPanelHeader.innerHTML = env.ENGINE.leftHeader;
          _elmnts.rightPanelHeader.innerHTML = env.ENGINE.rightHeader;
          _elmnts.footer.innerHTML = env.ENGINE.footer;
          _elmnts.canvas.innerHTML = 'Your browser does not support the &ltcanvas&gt tag';
          _elmnts.canvas.width = _elmnts.canvas.clientWidth;
          _elmnts.canvas.height = _elmnts.canvas.clientHeight;
          _elmnts.canvas.getContext('2d').translate(_elmnts.canvas.width / 2, _elmnts.canvas.height / 2);
          _ctx = _elmnts.canvas.getContext('2d');
          _ctx.save();
          _ctx.globalAlpha = 1.0;
          _ctx.textAlign = 'center';
          _ctx.textBaseline = 'middle';
          _ctx.font = "" + env.STARTUP.size + "px " + env.STARTUP.font;
          _ctx.fillStyle = env.STARTUP.color;
          _ctx.fillText(env.STARTUP.text, 0, 0);
          _ctx.restore();
          _elmnts.canvas.onclick = function() {
            _startEverything();
            Greenhorn.changeState(stateName != null ? stateName : 'GREENHORN');
            return _elmnts.canvas.onclick = function(e) {
              return Sprite.emitAll('mouse:click');
            };
          };
          return _firstTime = false;
        } else {
          _startEverything();
          if (stateName) {
            return Greenhorn.changeState(stateName);
          }
        }
      }
    };

    return Greenhorn;

  })();

  _mixin(Greenhorn, EventEmitter.prototype);

  gh.Greenhorn = Greenhorn;


  /*
  geometry.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  this.Point = (function() {
    function Point(_x, _y, _sprite) {
      this._x = _x;
      this._y = _y;
      this._sprite = _sprite;
    }

    Point.prototype.get = function(what) {
      if (what === 'x') {
        return this._x + this._sprite._pos.x;
      } else if (what === 'y') {
        return this._y + this._sprite._pos.y;
      } else if (what === 'a') {
        return Math.atan2(this._y, this._x);
      } else if (what === 'dist') {
        return Math.sqrt(Math.pow(this._y, 2) + Math.pow(this._x, 2));
      } else {
        throw new Error("" + what + " is not a get-able Point attribute");
      }
    };

    Point.prototype.set = function(what, to) {
      var _x, _y;
      if (what === 'x') {
        this._x = to;
      } else if (what === 'y') {
        this._y = to;
      } else if (what === 'a') {
        _x = this.get('dist') * Math.cos(to);
        _y = this.get('dist') * Math.sin(to);
        this.set('x', _x);
        this.set('y', _y);
      } else if (what === 'dist') {
        _x = to * Math.cos(this.get('a'));
        _y = to * Math.sin(this.get('a'));
        this.set('x', _x);
        this.set('y', _y);
      } else {
        throw new Error("" + what + " is not a set-able Point attribute");
      }
      return this;
    };

    Point.prototype.change = function(what, step) {
      var _x, _y;
      if (what === 'x') {
        this._x += step;
      } else if (what === 'y') {
        this._y += step;
      } else if (what === 'a') {
        _x = this.get('dist') * Math.cos(this.get('a') + step);
        _y = this.get('dist') * Math.sin(this.get('a') + step);
        this.set('x', _x);
        this.set('y', _y);
      } else if (what === 'dist') {
        _x = step * Math.cos(this.get('a'));
        _y = step * Math.sin(this.get('a'));
        this.change('x', _x);
        this.change('y', _y);
      } else {
        throw new Error("" + what + " is not a change-able Point attribute");
      }
      return this;
    };

    return Point;

  })();

  this.Line = (function() {
    function Line(p1, p2) {
      var _ref, _ref1;
      this.p1 = p1;
      this.p2 = p2;
      if (this.p1.get('x') > this.p2.get('x')) {
        _ref = [this.p2, this.p1], this.p1 = _ref[0], this.p2 = _ref[1];
      } else if (Math.abs(this.p1.get('x') - this.p2.get('x')) < .1 && this.p1.get('y') > this.p2.get('y')) {
        _ref1 = [this.p2, this.p1], this.p1 = _ref1[0], this.p2 = _ref1[1];
      }
    }

    Line.prototype.get = function(what) {
      if (what === 'm') {
        if (Math.abs(this.p1.get('x') - this.p2.get('x')) < .1) {
          return void 0;
        } else {
          return (this.p2.get('y') - this.p1.get('y')) / (this.p2.get('x') - this.p1.get('x'));
        }
      } else if (what === 'b') {
        if (Math.abs(this.p1.get('x') - this.p2.get('x')) < .1) {
          return void 0;
        } else {
          return -this.get('m') * this.p1.get('x') + this.p1.get('y');
        }
      } else {
        throw new Error("" + what + " is not a get-able Line attribute");
      }
    };

    Line.prototype.collidesWith = function(other) {
      var _int;
      if (_int = this._intersection(other)) {
        if (this._contains(_int)) {
          if (other._contains(_int)) {
            return true;
          }
        }
      }
      return false;
    };

    Line.prototype._contains = function(pt) {
      var _ref, _ref1;
      if (Math.abs(this.p1.get('x') - this.p2.get('x')) < .1) {
        if (Math.abs(this.p1.get('x') - pt.get('x')) < .1) {
          if ((this.p1.get('y') <= (_ref = pt.get('y')) && _ref <= this.p2.get('y'))) {
            return true;
          }
        }
      } else if ((this.p1.get('x') <= (_ref1 = pt.get('x')) && _ref1 <= this.p2.get('x'))) {
        if (Math.abs((this.get('m') * pt.get('x') + this.get('b')) - pt.get('y')) < .1) {
          return true;
        }
      }
      return false;
    };

    Line.prototype._intersection = function(other) {
      var _x, _y;
      if (this.get('m') === void 0 && other.get('m') === void 0) {
        return void 0;
      } else if (this.get('m') === void 0) {
        _x = this.p1.get('x');
        _y = other.get('m') * _x + other.get('b');
      } else if (other.get('m') === void 0) {
        _x = other.p1.get('x');
        _y = this.get('m') * _x + this.get('b');
      } else if (Math.abs(this.get('m') - other.get('m')) < .1) {
        return void 0;
      } else {
        _x = (other.get('b') - this.get('b')) / (this.get('m') - other.get('m'));
        _y = this.get('m') * _x + this.get('b');
      }
      return new Point(_x, _y, {
        _pos: {
          x: 0,
          y: 0
        }
      });
    };

    return Line;

  })();


  /*
  sprite.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  Sprite = (function(_super) {
    var _boundaryCallback, _bounds, _canvas, _list, _sortRule;

    __extends(Sprite, _super);

    _list = [];

    _canvas = null;

    _bounds = null;

    _sortRule = function(sp1, sp2) {
      return sp1._dis.level - sp2._dis.level;
    };

    _boundaryCallback = function(ba, side) {
      if (_bounds == null) {
        _bounds = {
          top: _canvas.height / 2,
          bottom: -_canvas.height / 2,
          right: _canvas.width / 2,
          left: -_canvas.width / 2
        };
      }
      switch (ba) {
        case 'DIE':
          return function() {
            return this.set('visible', false, false);
          };
        case 'WRAP':
          switch (side) {
            case 'top':
              return function() {
                return this.set('top', _bounds.bottom, false);
              };
            case 'bottom':
              return function() {
                return this.set('bottom', _bounds.top, false);
              };
            case 'right':
              return function() {
                return this.set('right', _bounds.left, false);
              };
            case 'left':
              return function() {
                return this.set('left', _bounds.right, false);
              };
          }
          break;
        case 'STOP':
          switch (side) {
            case 'top':
              return function() {
                return this.set('top', _bounds.top - 1, false);
              };
            case 'bottom':
              return function() {
                return this.set('bottom', _bounds.bottom + 1, false);
              };
            case 'right':
              return function() {
                return this.set('right', _bounds.right - 1, false);
              };
            case 'left':
              return function() {
                return this.set('left', _bounds.left + 1, false);
              };
          }
          break;
        case 'SPRING':
          switch (side) {
            case 'top':
              return function() {
                return this.change('dy', env.SPRING_CONSTANT * (_bounds.top - this.get('top', false)), false);
              };
            case 'bottom':
              return function() {
                return this.change('dy', env.SPRING_CONSTANT * (_bounds.bottom - this.get('bottom', false)), false);
              };
            case 'right':
              return function() {
                return this.change('dx', env.SPRING_CONSTANT * (_bounds.right - this.get('right', false)), false);
              };
            case 'left':
              return function() {
                return this.change('dx', env.SPRING_CONSTANT * (_bounds.left - this.get('left', false)), false);
              };
          }
          break;
        case 'BOUNCE':
          switch (side) {
            case 'top':
              return function() {
                this.set('top', _bounds.top - 1, false);
                return this._mot.dy *= -1 + env.BOUNCE_DECAY;
              };
            case 'bottom':
              return function() {
                this.set('bottom', _bounds.bottom + 1, false);
                return this._mot.dy *= -1 + env.BOUNCE_DECAY;
              };
            case 'right':
              return function() {
                this.set('right', _bounds.right - 1, false);
                return this._mot.dx *= -1 + env.BOUNCE_DECAY;
              };
            case 'left':
              return function() {
                this.set('left', _bounds.left + 1, false);
                return this._mot.dx *= -1 + env.BOUNCE_DECAY;
              };
          }
      }
    };

    Sprite.howMany = function() {
      return _list.length;
    };

    Sprite.getAll = function() {
      var excep, sp, what, _i, _len, _results;
      what = arguments[0], excep = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.get(what));
        }
      }
      return _results;
    };

    Sprite.setAll = function() {
      var excep, sp, to, what, _i, _len;
      what = arguments[0], to = arguments[1], excep = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          sp.set(what, to);
        }
      }
    };

    Sprite.changeAll = function() {
      var excep, sp, step, what, _i, _len;
      what = arguments[0], step = arguments[1], excep = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          sp.change(what, step);
        }
      }
    };

    Sprite.emitAll = function() {
      var args, event, sp, _i, _len;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        sp.emit.apply(sp, [event].concat(__slice.call(args)));
      }
    };

    Sprite.remove = function(sprite) {
      var i, sp, _i, _len;
      if (sprite.isRunning()) {
        sprite._stop();
      }
      for (i = _i = 0, _len = _list.length; _i < _len; i = ++_i) {
        sp = _list[i];
        if (!(sp === sprite)) {
          continue;
        }
        _list.splice(i, 1);
        return;
      }
    };

    Sprite.removeAll = function() {
      var excep, sp, _i, _j, _len, _len1;
      excep = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          if (sp.isRunning()) {
            sp._stop();
          }
        }
      }
      _list = [];
      for (_j = 0, _len1 = excep.length; _j < _len1; _j++) {
        sp = excep[_j];
        _list.push(sp);
      }
      _list.sort(_sortRule);
    };

    Sprite._drawAll = function() {
      var sp, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        sp._draw();
      }
    };

    Sprite._startAll = function() {
      var sp, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        sp._start();
      }
    };

    Sprite._stopAll = function() {
      var sp, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        sp._stop();
      }
    };

    function Sprite(config) {
      var angles, key, magnitudes, size, value, _a, _dist, _ref;
      if (config == null) {
        config = {};
      }
      this._update = __bind(this._update, this);
      if (_canvas == null) {
        _canvas = document.getElementById('gh-canvas') || document.createElement('canvas');
      }
      _ref = env.SPRITE_DEFAULT_CONFIG;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      size = {};
      angles = {};
      magnitudes = {};
      for (key in config) {
        if (!__hasProp.call(config, key)) continue;
        value = config[key];
        if (key.match(/(^width$|^height$)/)) {
          delete config[key];
          size[key] = value;
        } else if (key.match(/(^distance$|^speed$|^rate$|^scale$)/i)) {
          delete config[key];
          magnitudes[key] = value;
        } else if (key.match(/(^posAngle$|^motAngle$|^accAngle$)/)) {
          delete config[key];
          angles[key] = value;
        } else if (key.match(/^ba$/)) {
          delete config[key];
          config.ba_top = value;
          config.ba_bottom = value;
          config.ba_right = value;
          config.ba_left = value;
        } else if (key.match(/^on-\w+/)) {
          delete config[key];
          if (typeof value === 'function') {
            this.on(key.slice(3), value);
          } else if (value.length != null) {
            this.on(key.slice(3), value[0], value[1]);
          }
        } else if (key.match(/^once-\w+/)) {
          delete config[key];
          if (typeof value === 'function') {
            this.once(key.slice(5), value);
          } else if (value.length != null) {
            this.once(key.slice(5), value[0], value[1]);
          }
        }
      }
      if (config.bounds == null) {
        if (config.shape === 'polygon') {
          _a = Math.atan2(size.height / 2, size.width / 2);
          _dist = Math.sqrt(Math.pow(size.height / 2, 2) + Math.pow(size.width / 2, 2));
          config.bounds = [
            {
              x: _dist * Math.cos(config.a + _a),
              y: _dist * Math.sin(config.a + _a)
            }, {
              x: _dist * Math.cos(config.a - _a),
              y: _dist * Math.sin(config.a - _a)
            }, {
              x: _dist * Math.cos(config.a + Math.PI + _a),
              y: _dist * Math.sin(config.a + Math.PI + _a)
            }, {
              x: _dist * Math.cos(config.a + Math.PI - _a),
              y: _dist * Math.sin(config.a + Math.PI - _a)
            }
          ];
        } else if (config.shape === 'circle') {
          if (config.radius == null) {
            config.radius = Math.sqrt(Math.pow(size.height / 2, 2) + Math.pow(size.width / 2, 2));
          }
        } else {
          throw new Error("config.shape must be either 'polygon' or 'circle'");
        }
      } else {
        if (config.shape !== 'polygon') {
          throw new Error("if config.bounds is defined, config.shape must be 'polygon'");
        }
      }
      this._updateID = null;
      this._pos = {};
      this._mot = {};
      this._acc = {};
      this._dis = {};
      this._bas = {};
      this._bnd = {};
      this._dis.width = size.width;
      this._dis.height = size.height;
      this._dis.context = _canvas.getContext('2d');
      this._dis.image = document.createElement('img');
      this.set('config', config, false);
      this.set('config', magnitudes, false);
      this.set('config', angles, false);
      if (Greenhorn.isRunning()) {
        this._start();
      }
      _list.push(this);
      _list.sort(_sortRule);
    }

    Sprite.prototype.isRunning = function() {
      return this._updateID != null;
    };

    Sprite.prototype._start = function() {
      this.emit('start');
      return this._updateID = setInterval(this._update, 1000 / env.FRAME_RATE);
    };

    Sprite.prototype._stop = function() {
      this.emit('stop');
      clearInterval(this._updateID);
      return this._updateID = null;
    };

    Sprite.prototype.get = function(what, _emit) {
      var pt, value;
      if (_emit == null) {
        _emit = true;
      }
      if (what.match(/^imageFile$/)) {
        value = this._dis.image.src;
      } else if (what.match(/(^x$|^y$|^a$)/)) {
        value = this._pos[what];
      } else if (what.match(/(^dx$|^dy$|^da$)/)) {
        value = this._mot[what];
      } else if (what.match(/(^ddx$|^ddy$|^dda$)/)) {
        value = this._acc[what];
      } else if (what.match(/^top$/)) {
        if (this._bnd.shape === 'polygon') {
          value = (function() {
            var _i, _len, _ref, _results;
            _ref = this._bnd.points;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              pt = _ref[_i];
              _results.push(pt.get('y'));
            }
            return _results;
          }).call(this);
          value = Math.max.apply(Math, value);
        } else if (this._bnd.shape === 'circle') {
          value = this._pos.y + this._bnd.radius;
        }
      } else if (what.match(/^bottom$/)) {
        if (this._bnd.shape === 'polygon') {
          value = (function() {
            var _i, _len, _ref, _results;
            _ref = this._bnd.points;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              pt = _ref[_i];
              _results.push(pt.get('y'));
            }
            return _results;
          }).call(this);
          value = Math.min.apply(Math, value);
        } else if (this._bnd.shape === 'circle') {
          value = this._pos.y - this._bnd.radius;
        }
      } else if (what.match(/^right$/)) {
        if (this._bnd.shape === 'polygon') {
          value = (function() {
            var _i, _len, _ref, _results;
            _ref = this._bnd.points;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              pt = _ref[_i];
              _results.push(pt.get('x'));
            }
            return _results;
          }).call(this);
          value = Math.max.apply(Math, value);
        } else if (this._bnd.shape === 'circle') {
          value = this._pos.x + this._bnd.radius;
        }
      } else if (what.match(/^left$/)) {
        if (this._bnd.shape === 'polygon') {
          value = (function() {
            var _i, _len, _ref, _results;
            _ref = this._bnd.points;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              pt = _ref[_i];
              _results.push(pt.get('x'));
            }
            return _results;
          }).call(this);
          value = Math.min.apply(Math, value);
        } else if (this._bnd.shape === 'circle') {
          value = this._pos.x - this._bnd.radius;
        }
      } else if (what.match(/^radius$/)) {
        if (this._bnd.radius != null) {
          value = this._bnd.radius;
        } else {
          value = (function() {
            var _i, _len, _ref, _results;
            _ref = this._bnd.points;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              pt = _ref[_i];
              _results.push(pt.get('dist'));
            }
            return _results;
          }).call(this);
          value = Math.max.apply(Math, value);
        }
      } else if (what.match(/^distance$/)) {
        value = Math.sqrt(Math.pow(this._pos.x, 2) + Math.pow(this._pos.y, 2));
      } else if (what.match(/^speed$/)) {
        value = Math.sqrt(Math.pow(this._mot.dx, 2) + Math.pow(this._mot.dy, 2));
      } else if (what.match(/^rate$/)) {
        value = Math.sqrt(Math.pow(this._acc.ddx, 2) + Math.pow(this._acc.ddy, 2));
      } else if (what.match(/^posAngle$/)) {
        value = Math.atan2(this._pos.y, this._pos.x);
      } else if (what.match(/^motAngle$/)) {
        value = Math.atan2(this._mot.dy, this._mot.dx);
      } else if (what.match(/^accAngle$/)) {
        value = Math.atan2(this._acc.ddy, this._acc.ddx);
      } else if (what.match(/(^width$|^height$)/)) {
        value = this._dis[what] * this._dis.scale;
      } else if (what.match(/(^level$|^scale$|^visible$|^highlight$)/)) {
        value = this._dis[what];
      } else if (what.match(/^ba_(top|bottom|right|left)$/)) {
        value = this._bas[what.split('_')[1]].ba;
      } else if (what.match(/^shape$/)) {
        value = this._bnd.shape;
      } else {
        value = this[what];
      }
      if (_emit) {
        this.emit("get:" + what, value);
      }
      return value;
    };

    Sprite.prototype.set = function(what, to, _emit) {
      var diff, k, newCollision, old, oldCollision, proxy, pt, side, v, _bottom, _i, _j, _k, _l, _left, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _right, _top;
      if (_emit == null) {
        _emit = true;
      }
      if (what.match(/(^x$|^y$)/)) {
        if (_emit) {
          old = this._pos[what];
        }
        this._pos[what] = to;
      } else if (what.match(/^a$/)) {
        if (this._pos.a != null) {
          diff = to - this._pos.a;
        }
        if (_emit) {
          old = this._pos.a;
        }
        this._pos.a = to;
        if (diff && this._bnd.shape === 'polygon') {
          _ref = this._bnd.points;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            pt = _ref[_i];
            pt.change('a', diff);
          }
        }
      } else if (what.match(/(^dx$|^dy$|^da$)/)) {
        if (_emit) {
          old = this._mot[what];
        }
        this._mot[what] = to;
      } else if (what.match(/(^ddx$|^ddy$|^dda$)/)) {
        if (_emit) {
          old = this._acc[what];
        }
        this._acc[what] = to;
      } else if (what.match(/^top$/)) {
        if (_emit) {
          old = this.get('top', false);
        }
        if (this._bnd.shape === 'polygon') {
          _top = this._bnd.points[0];
          _ref1 = this._bnd.points;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            pt = _ref1[_j];
            if (pt._y > _top._y) {
              _top = pt;
            }
          }
          this._pos.y = to - _top._y;
        } else if (this._bnd.shape === 'circle') {
          this._pos.y = to - this.get('radius');
        }
      } else if (what.match(/^bottom$/)) {
        if (_emit) {
          old = this.get('bottom', false);
        }
        if (this._bnd.shape === 'polygon') {
          _bottom = this._bnd.points[0];
          _ref2 = this._bnd.points;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            pt = _ref2[_k];
            if (pt._y < _bottom._y) {
              _bottom = pt;
            }
          }
          this._pos.y = to - _bottom._y;
        } else if (this._bnd.shape === 'circle') {
          this._pos.y = to + this.get('radius');
        }
      } else if (what.match(/^right$/)) {
        if (_emit) {
          old = this.get('right', false);
        }
        if (this._bnd.shape === 'polygon') {
          _right = this._bnd.points[0];
          _ref3 = this._bnd.points;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            pt = _ref3[_l];
            if (pt._x > _right._x) {
              _right = pt;
            }
          }
          this._pos.x = to - _right._x;
        } else if (this._bnd.shape === 'circle') {
          this._pos.x = to - this.get('radius');
        }
      } else if (what.match(/^left$/)) {
        if (_emit) {
          old = this.get('left', false);
        }
        if (this._bnd.shape === 'polygon') {
          _left = this._bnd.points[0];
          _ref4 = this._bnd.points;
          for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
            pt = _ref4[_m];
            if (pt._x < _left._x) {
              _left = pt;
            }
          }
          this._pos.x = to - _left._x;
        } else if (this._bnd.shape === 'circle') {
          this._pos.x = to + this.get('radius');
        }
      } else if (what.match(/^radius$/)) {
        if (_emit) {
          old = this.get('radius', false);
        }
        if (this._bnd.shape === 'circle') {
          this._bnd.radius = to;
        } else {
          throw new Error("Cannot set radius when shape isnt 'circle'");
        }
      } else if (what.match(/^imageFile$/)) {
        if (_emit) {
          old = this.get('imageFile', false);
        }
        if (env.IMAGE_PATH.match(/\/$/)) {
          this._dis.image.src = env.IMAGE_PATH.concat(to);
        } else {
          if (env.IMAGE_PATH) {
            env.IMAGE_PATH += '/';
            this._dis.image.src = env.IMAGE_PATH.concat(to);
          } else {
            this._dis.image.src = to;
          }
        }
      } else if (what.match(/^distance$/)) {
        if (_emit) {
          old = this.get('distance', false);
        }
        proxy = {
          x: to * Math.cos(this.get('posAngle', false)),
          y: to * Math.sin(this.get('posAngle', false))
        };
        this.set('_pos', proxy, false);
      } else if (what.match(/^speed$/)) {
        if (_emit) {
          old = this.get('speed', false);
        }
        proxy = {
          dx: to * Math.cos(this.get('motAngle', false)),
          dy: to * Math.sin(this.get('motAngle', false))
        };
        this.set('_mot', proxy, false);
      } else if (what.match(/^rate$/)) {
        if (_emit) {
          old = this.get('rate', false);
        }
        proxy = {
          ddx: to * Math.cos(this.get('accAngle', false)),
          ddy: to * Math.sin(this.get('accAngle', false))
        };
        this.set('_acc', proxy, false);
      } else if (what.match(/^posAngle$/)) {
        if (_emit) {
          old = this.get('posAngle', false);
        }
        proxy = {
          x: this.get('distance', false) * Math.cos(to),
          y: this.get('distance', false) * Math.sin(to)
        };
        this.set('_pos', proxy, false);
      } else if (what.match(/^motAngle$/)) {
        if (_emit) {
          old = this.get('motAngle', false);
        }
        proxy = {
          dx: this.get('speed', false) * Math.cos(to),
          dy: this.get('speed', false) * Math.sin(to)
        };
        this.set('_mot', proxy, false);
      } else if (what.match(/^accAngle$/)) {
        if (_emit) {
          old = this.get('accAngle', false);
        }
        proxy = {
          ddx: this.get('rate', false) * Math.cos(to),
          ddy: this.get('rate', false) * Math.sin(to)
        };
        this.set('_acc', proxy, false);
      } else if (what.match(/(^_?dis|^_?pos|^_?mot|^_?acc|^config)/)) {
        for (k in to) {
          if (!__hasProp.call(to, k)) continue;
          v = to[k];
          this.set(k, v, false);
        }
      } else if (what.match(/(^level$|^visible$|^highlight$)/)) {
        if (_emit) {
          old = this._dis[what];
        }
        this._dis[what] = to;
        if (what === 'level') {
          _list.sort(_sortRule);
        }
      } else if (what.match(/^scale$/)) {
        if (this._dis.scale != null) {
          if (this._bnd.shape === 'polygon') {
            _ref5 = this._bnd.points;
            for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
              pt = _ref5[_n];
              pt.set('dist', pt.get('dist') / this._dis.scale);
            }
          } else if (this._bnd.shape === 'circle') {
            this.set('radius', this.get('radius') / this._dis.scale);
          }
        }
        if (_emit) {
          old = this._dis.scale;
        }
        this._dis.scale = to;
        if (this._bnd.shape === 'polygon') {
          _ref6 = this._bnd.points;
          for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
            pt = _ref6[_o];
            pt.set('dist', pt.get('dist') * this._dis.scale);
          }
        } else if (this._bnd.shape === 'circle') {
          this.set('radius', this.get('radius') * this._dis.scale);
        }
      } else if (what.match(/^ba$/)) {
        if (_emit) {
          old = {
            ba_top: this.bas['top'],
            ba_bottom: this.bas['bottom'],
            ba_right: this.bas['right'],
            ba_left: this.bas['left']
          };
        }
        proxy = {
          ba_top: to,
          ba_bottom: to,
          ba_right: to,
          ba_left: to
        };
        this.set('config', proxy, false);
      } else if (what.match(/^ba_(top|bottom|right|left)$/)) {
        side = what.split('_')[1];
        oldCollision = this._bas[side] != null ? this._bas[side].ba.match(/^(DIE|WRAP)$/) ? 'off' : 'hit' : '';
        newCollision = (function() {
          if (to.match(/(DIE|WRAP)/)) {
            return 'off';
          } else if (to.match(/^(STOP|SPRING|BOUNCE)$/)) {
            return 'hit';
          } else {
            throw new Error("" + to + " is not a valid boundary action");
          }
        })();
        if (_emit) {
          old = this._bas[side];
        }
        if (this._bas[side] != null) {
          this.remove("" + oldCollision + ":" + side, this._bas[side]);
        }
        this._bas[side] = _boundaryCallback(to, side);
        this._bas[side].ba = to;
        this.on("" + newCollision + ":" + side, this._bas[side]);
      } else if (what.match(/^shape$/)) {
        if (_emit) {
          old = this._bnd.shape;
        }
        if (this._bnd.shape === 'circle') {
          if (to === 'polygon') {
            this._bnd.radius = null;
            this._bnd.shape = to;
          }
        } else if (this._bnd.shape === 'polygon') {
          if (to === 'circle') {
            this._bnd.radius = this.get('radius');
            this._bnd.shape = to;
          }
        }
      } else if (what.match(/^points$/)) {
        if (_emit) {
          old = this._bnd.points.slice(0);
        }
        this._bnd.points = [];
        for (_p = 0, _len7 = to.length; _p < _len7; _p++) {
          pt = to[_p];
          if ((pt.x != null) && (pt.y != null)) {
            this._bnd.points.push(new Point(pt.x, pt.y, this));
          }
        }
      } else {
        if (_emit) {
          old = this[what];
        }
        this[what] = to;
      }
      if (_emit) {
        this.emit("set:" + what, old, to);
      }
      return this;
    };

    Sprite.prototype.change = function(what, step, _emit) {
      var k, proxy, pt, v, _i, _len, _ref;
      if (_emit == null) {
        _emit = true;
      }
      if (what.match(/(^x$|^y$|^a$)/)) {
        this._pos[what] += step / env.FRAME_RATE;
        if (what === 'a' && this._bnd.shape === 'polygon') {
          _ref = this._bnd.points;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            pt = _ref[_i];
            pt.change('a', step / env.FRAME_RATE);
          }
        }
      } else if (what.match(/(^dx$|^dy$|^da$)/)) {
        this._mot[what] += step / env.FRAME_RATE;
      } else if (what.match(/(^ddx$|^ddy$|^dda$)/)) {
        this._acc[what] += step / env.FRAME_RATE;
      } else if (what.match(/^level$/)) {
        this._dis.level += step / env.FRAME_RATE;
      } else if (what.match(/^distance$/)) {
        proxy = {
          dx: step * Math.cos(this.get('posAngle', false)),
          dy: step * Math.sin(this.get('posAngle', false))
        };
        this.change('_pos', proxy, false);
      } else if (what.match(/^speed$/)) {
        proxy = {
          ddx: step * Math.cos(this.get('motAngle', false)),
          ddy: step * Math.sin(this.get('motAngle', false))
        };
        this.change('_mot', proxy, false);
      } else if (what.match(/^rate$/)) {
        proxy = {
          dddx: step * Math.cos(this.get('accAngle', false)),
          dddy: step * Math.sin(this.get('accAngle', false))
        };
        this.change('_acc', proxy, false);
      } else if (what.match(/^posAngle$/)) {
        proxy = {
          x: this.get('distance', false) * Math.cos(step + this.get('posAngle', false)),
          y: this.get('distance', false) * Math.sin(step + this.get('posAngle', false))
        };
        this.set('_pos', proxy, false);
      } else if (what.match(/^motAngle$/)) {
        proxy = {
          dx: this.get('speed', false) * Math.cos(step + this.get('motAngle', false)),
          dy: this.get('speed', false) * Math.sin(step + this.get('motAngle', false))
        };
        this.set('_mot', proxy, false);
      } else if (what.match(/^accAngle$/)) {
        proxy = {
          ddx: this.get('rate', false) * Math.cos(step + this.get('accAngle', false)),
          ddy: this.get('rate', false) * Math.sin(step + this.get('accAngle', false))
        };
        this.set('_acc', proxy, false);
      } else if (what.match(/(^_?dis|^_?pos|^_?mot|^_?acc)/)) {
        for (k in step) {
          if (!__hasProp.call(step, k)) continue;
          v = step[k];
          this.change(k.slice(1), v, false);
        }
      } else {
        this[what] += step / env.FRAME_RATE;
      }
      if (_emit) {
        this.emit("change:" + what, step);
      }
      return this;
    };

    Sprite.prototype.collidesWith = function(other) {
      var i, innerLine, innerLines, mousePos, myLine, myLines, otherLine, otherLines, outerLine, outerLines, p1, p2, pt, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len12, _len13, _len14, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _s, _t, _u, _v, _w;
      if (other === 'mouse') {
        if (this._dis.visible) {
          if (this.distanceTo('mouse') <= this.get('radius', false)) {
            if (this._bnd.shape === 'circle') {
              return true;
            } else {
              outerLines = [];
              innerLines = [];
              mousePos = new Point(Greenhorn.getMouseX(), Greenhorn.getMouseY(), {
                _pos: {
                  x: 0,
                  y: 0
                }
              });
              _ref = this._bnd.points;
              for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                pt = _ref[i];
                innerLines.push(new Line(pt, mousePos));
                if (i === this._bnd.points.length - 1) {
                  outerLines.push(new Line(pt, this._bnd.points[0]));
                } else {
                  outerLines.push(new Line(pt, this._bnd.points[i + 1]));
                }
              }
              for (_j = 0, _len1 = innerLines.length; _j < _len1; _j++) {
                innerLine = innerLines[_j];
                for (_k = 0, _len2 = outerLines.length; _k < _len2; _k++) {
                  outerLine = outerLines[_k];
                  if (!innerLine._contains(outerLine.p1)) {
                    if (!innerLine._contains(outerLine.p2)) {
                      if (innerLine.collidesWith(outerLine)) {
                        return false;
                      }
                    }
                  }
                }
              }
              return true;
            }
          }
        }
        return false;
      } else {
        if (this._dis.visible) {
          if (other._dis.visible) {
            if (this._dis.level === other._dis.level) {
              if (this.distanceTo(other) <= this.get('radius', false) + other.get('radius', false)) {
                if (this._bnd.shape === 'circle' || other._bnd.shape === 'circle') {
                  return true;
                } else {
                  myLines = [];
                  otherLines = [];
                  _ref1 = this._bnd.points;
                  for (i = _l = 0, _len3 = _ref1.length; _l < _len3; i = ++_l) {
                    pt = _ref1[i];
                    if (i === this._bnd.points.length - 1) {
                      myLines.push(new Line(pt, this._bnd.points[0]));
                    } else {
                      myLines.push(new Line(pt, this._bnd.points[i + 1]));
                    }
                  }
                  _ref2 = other._bnd.points;
                  for (i = _m = 0, _len4 = _ref2.length; _m < _len4; i = ++_m) {
                    pt = _ref2[i];
                    if (i === other._bnd.points.length - 1) {
                      otherLines.push(new Line(pt, other._bnd.points[0]));
                    } else {
                      otherLines.push(new Line(pt, other._bnd.points[i + 1]));
                    }
                  }
                  for (_n = 0, _len5 = myLines.length; _n < _len5; _n++) {
                    myLine = myLines[_n];
                    for (_o = 0, _len6 = otherLines.length; _o < _len6; _o++) {
                      otherLine = otherLines[_o];
                      if (myLine.collidesWith(otherLine)) {
                        return true;
                      }
                    }
                  }
                  if (this.get('top') < other.get('top')) {
                    if (this.get('bottom') > other.get('bottom')) {
                      if (this.get('right') < other.get('right')) {
                        if (this.get('left') > other.get('left')) {
                          myLines = [];
                          _ref3 = other._bnd.points;
                          for (_p = 0, _len7 = _ref3.length; _p < _len7; _p++) {
                            p1 = _ref3[_p];
                            _ref4 = this._bnd.points;
                            for (_q = 0, _len8 = _ref4.length; _q < _len8; _q++) {
                              p2 = _ref4[_q];
                              myLines.push(new Line(p1, p2));
                            }
                          }
                          for (_r = 0, _len9 = myLines.length; _r < _len9; _r++) {
                            myLine = myLines[_r];
                            for (_s = 0, _len10 = otherLines.length; _s < _len10; _s++) {
                              otherLine = otherLines[_s];
                              if (!myLine._contains(otherLine.p1)) {
                                if (!myLine._contains(otherLine.p2)) {
                                  if (myLine.collidesWith(otherLine)) {
                                    return false;
                                  }
                                }
                              }
                            }
                          }
                          return true;
                        }
                      }
                    }
                  }
                  if (other.get('top') < this.get('top')) {
                    if (other.get('bottom') > this.get('bottom')) {
                      if (other.get('right') < this.get('right')) {
                        if (other.get('left') > this.get('left')) {
                          otherLines = [];
                          _ref5 = this._bnd.points;
                          for (_t = 0, _len11 = _ref5.length; _t < _len11; _t++) {
                            p1 = _ref5[_t];
                            _ref6 = other._bnd.points;
                            for (_u = 0, _len12 = _ref6.length; _u < _len12; _u++) {
                              p2 = _ref6[_u];
                              otherLines.push(new Line(p1, p2));
                            }
                          }
                          for (_v = 0, _len13 = otherLines.length; _v < _len13; _v++) {
                            otherLine = otherLines[_v];
                            for (_w = 0, _len14 = myLines.length; _w < _len14; _w++) {
                              myLine = myLines[_w];
                              if (!otherLine._contains(myLine.p1)) {
                                if (!otherLine._contains(myLine.p2)) {
                                  if (otherLine.collidesWith(myLine)) {
                                    return false;
                                  }
                                }
                              }
                            }
                          }
                          return true;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return false;
      }
    };

    Sprite.prototype.distanceTo = function(other) {
      var otherX, otherY;
      otherX = otherY = 0;
      if (other === 'mouse') {
        otherX = Greenhorn.getMouseX();
        otherY = Greenhorn.getMouseY();
      } else {
        otherX = other._pos.x;
        otherY = other._pos.y;
      }
      return Math.sqrt(Math.pow(this._pos.x - otherX, 2) + Math.pow(this._pos.y - otherY, 2));
    };

    Sprite.prototype.angleTo = function(other) {
      var otherX, otherY;
      otherX = otherY = 0;
      if (other === 'mouse') {
        otherX = Greenhorn.getMouseX();
        otherY = Greenhorn.getMouseY();
      } else {
        otherX = other._pos.x;
        otherY = other._pos.y;
      }
      return Math.atan2(otherY - this._pos.y, otherX - this._pos.x);
    };

    Sprite.prototype._draw = function() {
      var i, pt, _i, _len, _ref;
      if (this._dis.visible) {
        this._dis.context.save();
        this.emit('draw:before');
        this._dis.context.translate(this._pos.x, -this._pos.y);
        this._dis.context.rotate(-this._pos.a);
        this._dis.context.scale(this._dis.scale, this._dis.scale);
        this._dis.context.drawImage(this._dis.image, -this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
        this._dis.context.restore();
        if (this._dis.highlight) {
          this._dis.context.save();
          this._dis.context.lineWidth = 3;
          this._dis.context.strokeStyle = 'white';
          this._dis.context.beginPath();
          this._dis.context.moveTo(this._bnd.points[0].get('x'), -this._bnd.points[0].get('y'));
          _ref = this._bnd.points;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            pt = _ref[i];
            if (i !== 0) {
              this._dis.context.lineTo(pt.get('x'), -pt.get('y'));
            }
          }
          this._dis.context.closePath();
          this._dis.context.stroke();
          this._dis.context.restore();
        }
        return this.emit('draw:after');
      }
    };

    Sprite.prototype._update = function() {
      var event, key, keys, listeners, token, tokens, _emit, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
      this.emit('update');
      this.change('_mot', this._acc, false);
      this.change('_pos', this._mot, false);
      if (this.get('bottom', false) > _bounds.top) {
        this.emit('off:top');
      }
      if (this.get('top', false) < _bounds.bottom) {
        this.emit('off:bottom');
      }
      if (this.get('left', false) > _bounds.right) {
        this.emit('off:right');
      }
      if (this.get('right', false) < _bounds.left) {
        this.emit('off:left');
      }
      if (this.get('top', false) >= _bounds.top) {
        this.emit('hit:top');
      }
      if (this.get('bottom', false) <= _bounds.bottom) {
        this.emit('hit:bottom');
      }
      if (this.get('right', false) >= _bounds.right) {
        this.emit('hit:right');
      }
      if (this.get('left', false) <= _bounds.left) {
        this.emit('hit:left');
      }
      _ref = this._events;
      for (event in _ref) {
        if (!__hasProp.call(_ref, event)) continue;
        listeners = _ref[event];
        if (event.match(/^mouse:hover$/)) {
          if (this.collidesWith('mouse')) {
            this.emit(event);
          }
        }
        if (event.match(/^mouse:!hover$/)) {
          if (!this.collidesWith('mouse')) {
            this.emit(event);
          }
        }
        if (event.match(/^isDown:(\w+|\d)/)) {
          token = event.split(':')[1].toUpperCase();
          if (token.match(/-/)) {
            _emit = false;
            keys = token.split('-');
            for (_i = 0, _len = keys.length; _i < _len; _i++) {
              key = keys[_i];
              if (Greenhorn.isDown[KEYS[key]]) {
                _emit = true;
              }
            }
            if (_emit) {
              this.emit(event);
            }
          } else if (token.match(/\+/)) {
            _emit = true;
            keys = token.split('+');
            for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
              key = keys[_j];
              if (!Greenhorn.isDown[KEYS[key]]) {
                _emit = false;
              }
            }
            if (_emit) {
              this.emit(event);
            }
          } else {
            if (Greenhorn.isDown[KEYS[token]]) {
              this.emit(event);
            }
          }
        } else if (event.match(/^isUp:(\w+|\d)/)) {
          token = event.split(':')[1].toUpperCase();
          if (token.match(/-/)) {
            _emit = false;
            keys = token.split('-');
            for (_k = 0, _len2 = keys.length; _k < _len2; _k++) {
              key = keys[_k];
              if (!Greenhorn.isDown[KEYS[key]]) {
                _emit = true;
              }
            }
            if (_emit) {
              this.emit(event);
            }
          } else if (token.match(/\+/)) {
            _emit = true;
            keys = token.split('+');
            for (_l = 0, _len3 = keys.length; _l < _len3; _l++) {
              key = keys[_l];
              if (Greenhorn.isDown[KEYS[key]]) {
                _emit = false;
              }
            }
            if (_emit) {
              this.emit(event);
            }
          } else {
            if (!Greenhorn.isDown[KEYS[token]]) {
              this.emit(event);
            }
          }
        } else if (event.match(/^collisionWith:\w+/)) {
          if (this.collidesWith(listeners.other)) {
            this.emit(event, listeners.other);
          }
        } else if (event.match(/^!collisionWith:\w+/)) {
          if (!this.collidesWith(listeners.other)) {
            this.emit(event, listeners.other);
          }
        } else if (event.match(/^distanceTo:\w+-(gt|lt|eq|ge|le|ne)-\d*\.?\d*$/)) {
          tokens = event.split(':')[1];
          tokens = tokens.split('-');
          tokens[2] = parseFloat(tokens[2]);
          switch (tokens[1]) {
            case 'gt':
              if (this.distanceTo(listeners.other) > tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'lt':
              if (this.distanceTo(listeners.other) < tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'eq':
              if (this.distanceTo(listeners.other) === tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'ge':
              if (this.distanceTo(listeners.other) >= tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'le':
              if (this.distanceTo(listeners.other) <= tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'ne':
              if (this.distanceTo(listeners.other) !== tokens[2]) {
                this.emit(event, listeners.other);
              }
          }
        } else if (event.match(/^angleTo:\w+-(gt|lt|eq|ge|le|ne)-\d*\.?\d*$/)) {
          tokens = event.split(':')[1];
          tokens = tokens.split('-');
          tokens[2] = parseFloat(tokens[2]);
          switch (tokens[1]) {
            case 'gt':
              if (this.angleTo(listeners.other) > tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'lt':
              if (this.angleTo(listeners.other) < tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'eq':
              if (this.angleTo(listeners.other) === tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'ge':
              if (this.angleTo(listeners.other) >= tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'le':
              if (this.angleTo(listeners.other) <= tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'ne':
              if (this.angleTo(listeners.other) !== tokens[2]) {
                this.emit(event, listeners.other);
              }
          }
        } else if (event.match(/^\w+-(gt|lt|eq|ge|le|ne)-\d*\.?\d*$/)) {
          tokens = event.split('-');
          tokens[2] = parseFloat(tokens[2]);
          switch (tokens[1]) {
            case 'gt':
              if (this.get(tokens[0], false) > tokens[2]) {
                this.emit(event);
              }
              break;
            case 'lt':
              if (this.get(tokens[0], false) < tokens[2]) {
                this.emit(event);
              }
              break;
            case 'eq':
              if (this.get(tokens[0], false) === tokens[2]) {
                this.emit(event);
              }
              break;
            case 'ge':
              if (this.get(tokens[0], false) >= tokens[2]) {
                this.emit(event);
              }
              break;
            case 'le':
              if (this.get(tokens[0], false) <= tokens[2]) {
                this.emit(event);
              }
              break;
            case 'ne':
              if (this.get(tokens[0], false) !== tokens[2]) {
                this.emit(event);
              }
          }
        } else if (event.match(/^\w+-(eq|ne)-\w+/)) {
          tokens = event.split('-');
          if (tokens[2].match(/(^true$|^false$)/)) {
            tokens[2] = (0, eval)(tokens[2]);
          }
          switch (tokens[1]) {
            case 'eq':
              if (this.get(tokens[0], false) === tokens[2]) {
                this.emit(event);
              }
              break;
            case 'ne':
              if (this.get(tokens[0], false) !== tokens[2]) {
                this.emit(event);
              }
          }
        }
      }
      return this;
    };

    Sprite.prototype.report = function() {
      return "position:\n    x: " + (this._pos.x.toFixed(2)) + "\n    y: " + (this._pos.y.toFixed(2)) + "\n    a: " + (this._pos.a.toFixed(2)) + "\nmotion:\n    dx: " + (this._mot.dx.toFixed(2)) + "\n    dy: " + (this._mot.dy.toFixed(2)) + "\n    da: " + (this._mot.da.toFixed(2)) + "\nacceleration:\n    ddx: " + (this._acc.ddx.toFixed(2)) + "\n    ddy: " + (this._acc.ddy.toFixed(2)) + "\n    dda: " + (this._acc.dda.toFixed(2)) + "\ndisplay:\n    level: " + this._dis.level + "\n    scale: " + this._dis.scale + "\n    width: " + this._dis.width + "\n    height: " + this._dis.height + "\n    visible: " + this._dis.visible + "\n    highlight: " + this._dis.highlight + "\nbound actions:\n    top: " + this._bas.top.ba + "\n    bottom: " + this._bas.bottom.ba + "\n    right: " + this._bas.right.ba + "\n    left: " + this._bas.left.ba;
    };

    return Sprite;

  })(EventEmitter);

  gh.Sprite = Sprite;


  /*
  aniSprite.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  AniCycle = (function() {
    function AniCycle(data) {
      this.frame = data.start;
      this.index = data.index;
      this.start = data.start;
      this.stop = data.stop;
      this.name = data.name;
    }

    return AniCycle;

  })();

  AniSprite = (function(_super) {
    __extends(AniSprite, _super);

    function AniSprite(config) {
      var initialCycle, key, value, _ref;
      if (config == null) {
        config = {};
      }
      _ref = env.ANISPRITE_DEFAULT_CONFIG;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      initialCycle = null;
      for (key in config) {
        if (!__hasProp.call(config, key)) continue;
        value = config[key];
        if (key.match(/(^current$|^animation$)/i)) {
          delete config[key];
          initialCycle = value;
        }
      }
      this._ani = {};
      this._ani.cycles = [];
      this._ani.timer = new Timer(true);
      AniSprite.__super__.constructor.call(this, config);
      if (initialCycle != null) {
        this.set('current', initialCycle, false);
      }
    }

    AniSprite.prototype.get = function(what, _emit) {
      var value;
      if (_emit == null) {
        _emit = true;
      }
      if (what.match(/(^current$|^animation$)/)) {
        value = this._ani.current.name;
      } else if (what.match(/(^cellWidth$|^cellHeight$|^frameRate$|^orientation$)/)) {
        value = this._ani[what];
      } else {
        value = AniSprite.__super__.get.call(this, what, false);
      }
      if (_emit) {
        this.emit("get:" + what);
      }
      return value;
    };

    AniSprite.prototype.set = function(what, to, _emit) {
      var cycle, _base, _i, _len, _ref, _ref1;
      if (_emit == null) {
        _emit = true;
      }
      if (what.match(/(^current$|^animation$)/)) {
        if (to !== this._ani.current.name) {
          this._ani.current.frame = this._ani.current.start;
          _ref = this._ani.cycles;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            cycle = _ref[_i];
            if (cycle.name === to) {
              this._ani.current = cycle;
            }
          }
        }
      } else if (what.match(/(^cellWidth$|^cellHeight$|^frameRate$|^orientation$)/)) {
        this._ani[what] = to;
      } else if (what.match(/^cycle/)) {
        if (to.index == null) {
          to.index = env.ANICYCLE_DEFAULT_CONFIG.index;
        }
        if (to.start == null) {
          to.start = env.ANICYCLE_DEFAULT_CONFIG.start;
        }
        if (to.stop == null) {
          to.stop = to.start + env.ANICYCLE_DEFAULT_CONFIG.numFrames - 1;
        }
        if (to.name == null) {
          to.name = (_ref1 = what.slice(5)) != null ? _ref1 : env.ANICYCLE_DEFAULT_CONFIG.name;
        }
        this._ani.cycles.push(new AniCycle(to));
        if ((_base = this._ani).current == null) {
          _base.current = this._ani.cycles[0];
        }
      } else {
        AniSprite.__super__.set.call(this, what, to, _emit);
        _emit = false;
      }
      if (_emit) {
        this.emit("set:" + what, to);
      }
      return this;
    };

    AniSprite.prototype.change = function(what, step, _emit) {
      if (_emit == null) {
        _emit = true;
      }
      if (what.match(/^frameRate$/)) {
        this._ani.frameRate += step / env.FRAME_RATE;
      } else {
        AniSprite.__super__.change.call(this, what, step, _emit);
        _emit = false;
      }
      if (_emit) {
        this.emit("change:" + what, step);
      }
      return this;
    };

    AniSprite.prototype.play = function() {
      this.emit('play');
      this._ani.timer.start();
      return this;
    };

    AniSprite.prototype.pause = function() {
      this.emit('pause');
      this._ani.timer.pause();
      return this;
    };

    AniSprite.prototype.stop = function() {
      this.emit('stop');
      this._ani.timer.stop();
      this._ani.current.frame = this._ani.current.start;
      return this;
    };

    AniSprite.prototype._draw = function() {
      var sliceX, sliceY;
      if (this._dis.visible) {
        this.emit('draw');
        this._dis.context.save();
        this._dis.context.translate(this._pos.x, -this._pos.y);
        this._dis.context.rotate(-this._pos.a);
        if (this._ani.orientation.toLowerCase() === 'horizontal') {
          sliceX = this._ani.current.frame - 1;
          sliceY = this._ani.current.index - 1;
        } else if (this._ani.orientation.toLowerCase() === 'vertical') {
          sliceX = this._ani.current.index - 1;
          sliceY = this._ani.current.frame - 1;
        }
        this._dis.context.drawImage(this._dis.image, this._ani.cellWidth * sliceX, this._ani.cellHeight * sliceY, this._ani.cellWidth, this._ani.cellHeight, -this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
        return this._dis.context.restore();
      }
    };

    AniSprite.prototype._update = function() {
      AniSprite.__super__._update.call(this);
      if (this._ani.timer.getElapsedTime() >= (1000 / this._ani.frameRate)) {
        if (this._ani.current.frame < this._ani.current.stop) {
          this._ani.current.frame += 1;
        } else {
          this._ani.current.frame = this._ani.current.start;
        }
        return this._ani.timer.restart();
      }
    };

    AniSprite.prototype.report = function() {
      return "" + (AniSprite.__super__.report.call(this)) + "\nanimation:\n    frameRate: " + this._ani.frameRate + "\n    cellWidth: " + this._ani.cellWidth + "\n    cellHeight: " + this._ani.cellHeight + "\n    orientation: " + this._ani.orientation + "\n    current cycle:\n        frame: " + this._ani.current.frame + "\n        index: " + this._ani.current.index + "\n        start: " + this._ani.current.start + "\n        stop: " + this._ani.current.stop + "\n        name: " + this._ani.current.name;
    };

    return AniSprite;

  })(Sprite);

  gh.AniSprite = AniSprite;


  /*
  textSprite.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  TextSprite = (function(_super) {
    __extends(TextSprite, _super);

    function TextSprite(config) {
      var key, value, _ref;
      if (config == null) {
        config = {};
      }
      _ref = env.TEXTSPRITE_DEFAULT_CONFIG;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      this._text = [];
      this._font = {};
      this._border = {};
      this._outline = {};
      this._margins = {};
      this._background = {};
      TextSprite.__super__.constructor.call(this, config);
    }

    TextSprite.prototype.get = function(what, _emit) {
      var value;
      if (_emit == null) {
        _emit = true;
      }
      if (what.match(/^text$/)) {
        value = this._text.join('\n');
      } else if (what.match(/^font\w+/)) {
        value = this._font[what.slice(4).toLowerCase()];
      } else if (what.match(/^border\w+/)) {
        value = this._border[what.slice(6).toLowerCase()];
      } else if (what.match(/^outline\w+/)) {
        value = this._outline[what.slice(7).toLowerCase()];
      } else if (what.match(/^margins\w+/)) {
        value = this._margins[what.slice(7).toLowerCase()];
      } else if (what.match(/^background\w+/)) {
        value = this._background[what.slice(10).toLowerCase()];
      } else {
        value = TextSprite.__super__.get.call(this, what, false);
      }
      if (_emit) {
        this.emit("get:" + what);
      }
      return value;
    };

    TextSprite.prototype.set = function(what, to, _emit) {
      var k, v;
      if (_emit == null) {
        _emit = true;
      }
      if (what.match(/^text$/)) {
        this._text = to.split('\n');
      } else if (what.match(/^font\w+/)) {
        this._font[what.slice(4).toLowerCase()] = to;
      } else if (what.match(/^border\w+/)) {
        this._border[what.slice(6).toLowerCase()] = to;
      } else if (what.match(/^outline\w+/)) {
        this._outline[what.slice(7).toLowerCase()] = to;
      } else if (what.match(/^margins\w+/)) {
        this._margins[what.slice(7).toLowerCase()] = to;
      } else if (what.match(/^background\w+/)) {
        this._background[what.slice(10).toLowerCase()] = to;
      } else if (what.match(/(^font$|^border$|^outline$|^margins$|^background$)/)) {
        for (k in to) {
          if (!__hasProp.call(to, k)) continue;
          v = to[k];
          this.set(what.concat(k), v, false);
        }
      } else {
        TextSprite.__super__.set.call(this, what, to, _emit);
        _emit = false;
      }
      if (_emit) {
        this.emit("set:" + what, to);
      }
      return this;
    };

    TextSprite.prototype.change = function(what, step, _emit) {
      var k, v;
      if (_emit == null) {
        _emit = true;
      }
      if (what.match(/^text$/)) {
        this._text = (this._text.join('\n').concat(step)).split('\n');
      } else if (what.match(/^font\w+/)) {
        this._font[what.slice(4).toLowerCase()] += step / env.FRAME_RATE;
      } else if (what.match(/^border\w+/)) {
        this._border[what.slice(6).toLowerCase()] += step / env.FRAME_RATE;
      } else if (what.match(/^outline\w+/)) {
        this._outline[what.slice(7).toLowerCase()] += step / env.FRAME_RATE;
      } else if (what.match(/^margins\w+/)) {
        this._margins[what.slice(7).toLowerCase()] += step / env.FRAME_RATE;
      } else if (what.match(/^background\w+/)) {
        this._background[what.slice(10).toLowerCase()] += step / env.FRAME_RATE;
      } else if (what.match(/(^font$|^border$|^outline$|^margins$|^background$)/i)) {
        for (k in to) {
          if (!__hasProp.call(to, k)) continue;
          v = to[k];
          this.change(what.concat(k), v, false);
        }
      } else {
        TextSprite.__super__.change.call(this, what, step, _emit);
        _emit = false;
      }
      if (_emit) {
        this.emit("change:" + what, step);
      }
      return this;
    };

    TextSprite.prototype._draw = function() {
      var i, line, xOffset, yOffset, _i, _j, _len, _len1, _ref, _ref1;
      if (this._dis.visible) {
        this.emit('draw');
        this._dis.context.save();
        this._dis.context.translate(this._pos.x, -this._pos.y);
        this._dis.context.rotate(-this._pos.a);
        if (this._background.visible) {
          this._dis.context.fillStyle = this._background.color;
          this._dis.context.globalAlpha = this._background.alpha;
          this._dis.context.fillRect(-this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
        }
        if (this._border.visible) {
          this._dis.context.strokeStyle = this._border.color;
          this._dis.context.lineWidth = this._border.size;
          this._dis.context.globalAlpha = this._border.alpha;
          this._dis.context.strokeRect(-this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
        }
        yOffset = (this._text.length - 1) * this._font.size * .75;
        if (this._font.align.toLowerCase() === 'center') {
          xOffset = 0;
        } else if (this._font.align.toLowerCase() === 'left') {
          xOffset = -this._dis.width / 2 + this._margins.left;
          if (this._border.visible) {
            xOffset += this._border.size;
          }
        } else if (this._font.align.toLowerCase() === 'right') {
          xOffset = this._dis.width / 2 - this._margins.right;
          if (this._border.visible) {
            xOffset -= this._border.size;
          }
        }
        this._dis.context.textBaseline = 'middle';
        this._dis.context.fillStyle = this._font.color;
        this._dis.context.globalAlpha = this._font.alpha;
        this._dis.context.textAlign = this._font.align;
        this._dis.context.font = "" + this._font.size + "px " + this._font.name;
        _ref = this._text;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          line = _ref[i];
          this._dis.context.fillText(line, xOffset, this._font.size * 1.5 * i - yOffset);
        }
        if (this._outline.visible) {
          this._dis.context.lineWidth = this._outline.size;
          this._dis.context.strokeStyle = this._outline.color;
          this._dis.context.globalAlpha = this._outline.alpha;
          _ref1 = this._text;
          for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
            line = _ref1[i];
            this._dis.context.strokeText(line, xOffset, this._font.size * 1.5 * i - yOffset);
          }
        }
        return this._dis.context.restore();
      }
    };

    TextSprite.prototype._update = function() {
      var len, line, _i, _len, _ref;
      TextSprite.__super__._update.call(this);
      this._dis.width = 0;
      this._dis.height = this._font.size * 1.5 * this._text.length;
      this._dis.context.save();
      this._dis.context.font = "" + this._font.size + "px " + this._font.name;
      _ref = this._text;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        len = this._dis.context.measureText(line).width;
        if (this._dis.width < len) {
          this._dis.width = len;
        }
      }
      this._dis.context.restore();
      this._dis.width += this._margins.left + this._margins.right;
      this._dis.height += this._margins.top + this._margins.bottom;
      if (this._border.visible) {
        this._dis.width += 2 * this._border.size;
        return this._dis.height += 2 * this._border.size;
      }
    };

    TextSprite.prototype.report = function() {
      return "" + (TextSprite.__super__.report.call(this)) + "\nfont:\n    size: " + this._font.size + "\n    alpha: " + this._font.alpha + "\n    color: " + this._font.color + "\n    align: " + this._font.align + "\n    name: " + this._font.name + "\nborder:\n    size: " + this._border.size + "\n    alpha: " + this._border.alpha + "\n    visible: " + this._border.visible + "\n    color: " + this._border.color + "\noutline:\n    size: " + this._outline.size + "\n    alpha: " + this._outline.alpha + "\n    visible: " + this._outline.visible + "\n    color: " + this._outline.color + "\nmargins:\n    top: " + this._margins.top + "\n    bottom: " + this._margins.bottom + "\n    right: " + this._margins.right + "\n    left: " + this._margins.left + "\nbackground:\n    alpha: " + this._background.alpha + "\n    visible: " + this._background.visible + "\n    color: " + this._background.color;
    };

    return TextSprite;

  })(Sprite);

  gh.TextSprite = TextSprite;


  /*
  timer.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  Timer = (function() {
    var currentTime;

    currentTime = function() {
      return (new Date()).getTime();
    };

    Timer.DEFAULTS = {
      startImmediately: true
    };

    function Timer(startImmediately) {
      if (startImmediately == null) {
        startImmediately = Timer.DEFAULTS.startImmediately;
      }
      this._elapsedTime = 0;
      this._startTime = startImmediately ? currentTime() : null;
    }

    Timer.prototype.isRunning = function() {
      return this._startTime != null;
    };

    Timer.prototype.getElapsedTime = function() {
      if (!this._startTime) {
        return this._elapsedTime;
      } else {
        return this._elapsedTime + currentTime() - this._startTime;
      }
    };

    Timer.prototype.start = function() {
      if (!this._startTime) {
        return this._startTime = currentTime();
      }
    };

    Timer.prototype.pause = function() {
      if (this._startTime) {
        this._elapsedTime += currentTime() - this._startTime;
        return this._startTime = null;
      }
    };

    Timer.prototype.restart = function() {
      this._elapsedTime = 0;
      return this._startTime = currentTime();
    };

    Timer.prototype.stop = function() {
      this._elapsedTime = 0;
      return this._startTime = null;
    };

    return Timer;

  })();

  gh.Timer = Timer;


  /*
  sound.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  if ((window.AudioContext != null) || (window.webkitAudioContext != null)) {
    AudioContext = (_ref = window.AudioContext) != null ? _ref : window.webkitAudioContext;
    _audioContext = new AudioContext();
  } else {
    env.USE_AUDIO_TAG = true;
  }

  Sound = (function() {
    var _list;

    _list = [];

    Sound._playAll = function() {
      var snd, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        snd = _list[_i];
        if (snd._config.autoplay) {
          snd.play();
        } else {
          snd.play({
            volume: 0,
            loop: false
          });
          setTimeout(snd.stop, 50);
        }
      }
    };

    Sound._pauseAll = function() {
      var snd, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        snd = _list[_i];
        snd.pause();
      }
    };

    Sound._stopAll = function() {
      var snd, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        snd = _list[_i];
        snd.stop();
      }
    };

    function Sound(_config) {
      var key, mp3_src, ogg_src, request, value, wav_src, _base, _ref1;
      this._config = _config != null ? _config : {};
      this.stop = __bind(this.stop, this);
      this.pause = __bind(this.pause, this);
      this.restart = __bind(this.restart, this);
      this.play = __bind(this.play, this);
      _ref1 = env.SOUND_DEFAULT_CONFIG;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        value = _ref1[key];
        if ((_base = this._config)[key] == null) {
          _base[key] = value;
        }
      }
      if (env.SOUND_PATH.match(/\/$/)) {
        this._config.url = env.SOUND_PATH.concat(this._config.url);
      } else {
        if (env.SOUND_PATH) {
          env.SOUND_PATH += '/';
          this._config.url = env.SOUND_PATH.concat(this._config.url);
        }
      }
      if (env.USE_AUDIO_TAG) {
        this._audio = document.createElement('audio');
        mp3_src = document.createElement('source');
        ogg_src = document.createElement('source');
        wav_src = document.createElement('source');
        mp3_src.type = 'audio/mpeg';
        ogg_src.type = 'audio/ogg';
        wav_src.type = 'audio/wav';
        if (this._config.url.match(/\.mp3$/)) {
          mp3_src.src = this._config.url;
          ogg_src.src = this._config.url.replace('.mp3', '.ogg');
          wav_src.src = this._config.url.replace('.mp3', '.wav');
        } else if (this._config.url.match(/\.ogg$/)) {
          ogg_src.src = this._config.url;
          mp3_src.src = this._config.url.replace('.ogg', '.mp3');
          wav_src.src = this._config.url.replace('.ogg', '.wav');
        } else if (this._config.url.match(/\.wav$/)) {
          wav_src.src = this._config.url;
          mp3_src.src = this._config.url.replace('.wav', '.mp3');
          ogg_src.src = this._config.url.replace('.wav', '.ogg');
        } else {
          throw new Error("Only .mp3, .ogg, and .wav file extensions are supported by the audio tag");
        }
        this._audio.appendChild(mp3_src);
        this._audio.appendChild(ogg_src);
        this._audio.appendChild(wav_src);
        if (Greenhorn.isRunning() && this._config.autoplay) {
          this._audio.autoplay = true;
        }
      } else {
        this._source = null;
        this._buffer = null;
        this._isEnded = true;
        this._startTime = 0;
        this._elapsedTime = 0;
        request = new XMLHttpRequest();
        request.open('GET', this._config.url, true);
        request.responseType = 'arraybuffer';
        request.successCallback = (function(_this) {
          return function(buffer) {
            _this._buffer = buffer;
            if (Greenhorn.isRunning() && _this._config.autoplay) {
              return _this.play();
            }
          };
        })(this);
        request.errorCallback = function() {
          throw new Error("AJAX request Error");
        };
        request.onload = function() {
          return _audioContext.decodeAudioData(this.response, this.successCallback, this.errorCallback);
        };
        request.send();
      }
      _list.push(this);
    }

    Sound.prototype.play = function(opt) {
      var gainNode, _ref1, _ref2, _ref3, _ref4;
      if (opt == null) {
        opt = {};
      }
      if (Greenhorn.isRunning()) {
        if (env.USE_AUDIO_TAG) {
          this._audio.loop = (_ref1 = opt.loop) != null ? _ref1 : this._config.loop;
          this._audio.volume = (_ref2 = opt.volume) != null ? _ref2 : this._config.volume;
          return this._audio.play();
        } else {
          if (this._isEnded) {
            this._isEnded = false;
            gainNode = _audioContext.createGain();
            this._source = _audioContext.createBufferSource();
            this._source.buffer = this._buffer;
            this._source.loop = (_ref3 = opt.loop) != null ? _ref3 : this._config.loop;
            this._source.onended = (function(_this) {
              return function() {
                _this._isEnded = true;
                _this._elapsedTime += _audioContext.currentTime - _this._startTime;
                if (_this._elapsedTime >= _this._buffer.duration) {
                  return _this._elapsedTime = 0;
                }
              };
            })(this);
            gainNode.gain.value = (_ref4 = opt.volume) != null ? _ref4 : this._config.volume;
            this._source.connect(gainNode);
            gainNode.connect(_audioContext.destination);
            this._startTime = _audioContext.currentTime;
            return this._source.start(this._startTime, this._elapsedTime);
          }
        }
      }
    };

    Sound.prototype.restart = function(opt) {
      var gainNode, _ref1, _ref2, _ref3, _ref4;
      if (opt == null) {
        opt = {};
      }
      if (Greenhorn.isRunning()) {
        if (env.USE_AUDIO_TAG) {
          this._audio.currentTime = 0;
          this._audio.loop = (_ref1 = opt.loop) != null ? _ref1 : this._config.loop;
          this._audio.volume = (_ref2 = opt.volume) != null ? _ref2 : this._config.volume;
          return this._audio.play();
        } else {
          this._source.stop();
          this._elapsedTime = 0;
          gainNode = _audioContext.createGain();
          this._source = _audioContext.createBufferSource();
          this._source.buffer = this._buffer;
          this._source.loop = (_ref3 = opt.loop) != null ? _ref3 : this._config.loop;
          this._source.onended = (function(_this) {
            return function() {
              _this._isEnded = true;
              return _this._elapsedTime = 0;
            };
          })(this);
          gainNode.gain.value = (_ref4 = opt.volume) != null ? _ref4 : this._config.volume;
          this._source.connect(gainNode);
          gainNode.connect(_audioContext.destination);
          this._startTime = _audioContext.currentTime;
          return this._source.start(this._startTime, this._elapsedTime);
        }
      }
    };

    Sound.prototype.pause = function() {
      if (Greenhorn.isRunning()) {
        if (env.USE_AUDIO_TAG) {
          return this._audio.pause();
        } else {
          return this._source.stop();
        }
      }
    };

    Sound.prototype.stop = function() {
      if (Greenhorn.isRunning()) {
        if (env.USE_AUDIO_TAG) {
          this._audio.pause();
          return this._audio.currentTime = 0;
        } else {
          this._source.stop();
          return this._elapsedTime = 0;
        }
      }
    };

    return Sound;

  })();

  gh.Sound = Sound;

}).call(this);
