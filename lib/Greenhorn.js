// Generated by CoffeeScript 1.8.0

/*
environment.coffee
Written by Seth Bullock
sedabull@gmail.com
 */

(function() {
  var AniCycle, AniSprite, AudioContext, EventEmitter, Greenhorn, Sound, Sprite, TextSprite, Timer, env, _audioContext, _masterID, _masterUpdate, _mixin, _ref,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.gh = Object.create(null);

  env = {
    FRAME_RATE: 25,
    BOUNCE_DECAY: 0,
    SPRING_CONSTANT: 25,
    ENGINE: {
      footer: 'FOOTER',
      leftHeader: 'LEFT PANEL',
      rightHeader: 'RIGHT PANEL'
    },
    STARTUP: {
      size: 50,
      color: '#006400',
      font: 'sans-serif',
      text: 'Click here to Start'
    },
    IMAGE_PATH: "./",
    SPRITE_DEFAULT_CONFIG: {
      x: 0,
      y: 0,
      a: 0,
      dx: 0,
      dy: 0,
      da: 0,
      ddx: 0,
      ddy: 0,
      dda: 0,
      level: 0,
      width: 64,
      height: 64,
      visible: true,
      imageFile: '',
      ba_top: 'WRAP',
      ba_bottom: 'WRAP',
      ba_right: 'WRAP',
      ba_left: 'WRAP'
    },
    TEXTSPRITE_DEFAULT_CONFIG: {
      level: -1,
      text: "*-TEXTSPRITE-*",
      fontSize: 12,
      fontAlpha: 1.0,
      fontColor: "white",
      fontAlign: "left",
      fontName: "sans-serif",
      borderSize: 5,
      borderAlpha: 1.0,
      borderVisible: true,
      borderColor: "white",
      outlineSize: 1,
      outlineAlpha: 1.0,
      outlineVisible: false,
      outlineColor: "grey",
      marginsTop: 5,
      marginsBottom: 5,
      marginsRight: 5,
      marginsLeft: 5,
      backgroundAlpha: 1.0,
      backgroundVisible: true,
      backgroundColor: "black"
    },
    ANICYCLE_DEFAULT_CONFIG: {
      index: 1,
      start: 1,
      numFrames: 8,
      name: 'UNDEFINED'
    },
    ANISPRITE_DEFAULT_CONFIG: {
      cellWidth: 32,
      cellHeight: 32,
      frameRate: 10,
      orientation: 'horizontal'
    },
    SOUND_PATH: "./",
    USE_AUDIO_TAG: false,
    SOUND_DEFAULT_CONFIG: {
      url: "",
      loop: false,
      volume: 1.0,
      autoplay: false
    },
    BUTTON_DEFAULT_CONFIG: {
      type: 'button',
      onclick: void 0,
      parent: 'rightPanel',
      label: 'Launch the Missiles!'
    },
    TIMER_START_ON_CONSTRUCTION: true
  };

  gh.env = env;


  /*
  eventEmitter.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  EventEmitter = (function() {
    function EventEmitter() {}

    EventEmitter.prototype.on = function(event, listener, options) {
      var key, value, _base;
      if (options == null) {
        options = {};
      }
      if (this._events == null) {
        this._events = {};
      }
      if ((_base = this._events)[event] == null) {
        _base[event] = [];
      }
      this._events[event].push(listener);
      for (key in options) {
        if (!__hasProp.call(options, key)) continue;
        value = options[key];
        this._events[event][key] = value;
      }
      return this;
    };

    EventEmitter.prototype.once = function(event, listener, options) {
      if (options == null) {
        options = {};
      }
      listener.once = true;
      return this.on(event, listener, options);
    };

    EventEmitter.prototype.emit = function() {
      var args, event, i, listener, _i, _len, _ref;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this._events == null) {
        this._events = {};
      }
      if (this._events[event] != null) {
        _ref = this._events[event];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          listener = _ref[_i];
          listener.apply(this, args);
          if (listener.once != null) {
            i = this._events[event].indexOf(listener);
            this._events[event].splice(i, 1);
          }
        }
        return true;
      }
      return false;
    };

    EventEmitter.prototype.remove = function(event, listener) {
      var cb, i, _i, _len, _ref;
      if (this._events == null) {
        this._events = {};
      }
      if (this._events[event] != null) {
        if (listener != null) {
          _ref = this._events[event];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            cb = _ref[i];
            if (!(cb === listener)) {
              continue;
            }
            this._events[event].splice(i, 1);
            if (this._events[event].length === 0) {
              delete this._events[event];
            }
          }
        } else {
          delete this._events[event];
        }
      }
      return this;
    };

    EventEmitter.prototype.listeners = function(event) {
      if (event != null) {
        return this._events[event];
      } else {
        return this._events;
      }
    };

    return EventEmitter;

  })();

  _mixin = function(dest, source) {
    var key, value;
    for (key in source) {
      if (!__hasProp.call(source, key)) continue;
      value = source[key];
      dest[key] = value;
    }
    return dest;
  };


  /*
  greenhorn.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  gh.KEYS = {
    ESC: 27,
    SPACE: 32,
    PGUP: 33,
    PGDOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    '0': 48,
    '1': 49,
    '2': 50,
    '3': 51,
    '4': 52,
    '5': 53,
    '6': 54,
    '7': 55,
    '8': 56,
    '9': 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90
  };

  document.onreadystatechange = function() {
    var _ref;
    if (this.readyState === 'interactive') {
      return ((_ref = gh.init) != null ? _ref : Greenhorn.start)();
    }
  };

  document.onkeydown = function(e) {
    e.preventDefault();
    return Greenhorn.isDown[e.keyCode] = true;
  };

  document.onkeyup = function(e) {
    e.preventDefault();
    return Greenhorn.isDown[e.keyCode] = false;
  };

  _masterID = null;

  _masterUpdate = function() {
    Greenhorn.clear();
    if (typeof gh.update === "function") {
      gh.update();
    }
    return Sprite._drawAll();
  };

  Greenhorn = (function() {
    var key, _elmnts, _firstTime, _i, _len, _ref, _startEverything;

    function Greenhorn() {}

    Greenhorn.isDown = new Array(256);

    _ref = Greenhorn.isDown;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      key = false;
    }

    _elmnts = {
      main: document.createElement('div'),
      title: document.createElement('h1'),
      leftPanel: document.createElement('div'),
      leftPanelHeader: document.createElement('h3'),
      canvas: document.createElement('canvas'),
      rightPanel: document.createElement('div'),
      rightPanelHeader: document.createElement('h3'),
      footer: document.createElement('div')
    };

    _elmnts.main.id = 'gh-main';

    _elmnts.title.id = 'gh-title';

    _elmnts.leftPanel.id = 'gh-left-panel';

    _elmnts.canvas.id = 'gh-canvas';

    _elmnts.rightPanel.id = 'gh-right-panel';

    _elmnts.footer.id = 'gh-footer';

    _elmnts.leftPanelHeader.classList.add('gh-h');

    _elmnts.rightPanelHeader.classList.add('gh-h');

    _elmnts.main.appendChild(_elmnts.title);

    _elmnts.main.appendChild(_elmnts.leftPanel);

    _elmnts.main.appendChild(_elmnts.canvas);

    _elmnts.main.appendChild(_elmnts.rightPanel);

    _elmnts.main.appendChild(_elmnts.footer);

    _elmnts.leftPanel.appendChild(_elmnts.leftPanelHeader);

    _elmnts.rightPanel.appendChild(_elmnts.rightPanelHeader);

    _elmnts.canvas.draggable = true;

    _elmnts.canvas.onmousemove = function(e) {
      this.mouseX = e.pageX;
      this.mouseY = e.pageY;
      return Sprite.emitAll('mouse:move');
    };

    _elmnts.canvas.onmousedown = function(e) {
      return Sprite.emitAll('mouse:down');
    };

    _elmnts.canvas.onmouseup = function(e) {
      return Sprite.emitAll('mouse:up');
    };

    _elmnts.canvas.ondblclick = function(e) {
      return Sprite.emitAll('mouse:doubleClick');
    };

    _elmnts.canvas.oncontextmenu = function(e) {
      e.preventDefault();
      return Sprite.emitAll('mouse:contextMenu');
    };

    _elmnts.canvas.ondrag = function(e) {
      e.preventDefault();
      return Sprite.emitAll('mouse:drag');
    };

    _elmnts.canvas.ondragstart = function(e) {
      e.preventDefault();
      return Sprite.emitAll('mouse:dragStart');
    };

    _elmnts.canvas.ondragend = function(e) {
      e.preventDefault();
      return Sprite.emitAll('mouse:dragEnd');
    };

    _startEverything = function() {
      _masterID = setInterval(_masterUpdate, 1000 / env.FRAME_RATE);
      Sprite._startAll();
      Sound._playAll();
    };

    Greenhorn.getMouseX = function() {
      var indexNode, mouseX;
      indexNode = _elmnts.canvas;
      mouseX = indexNode.mouseX - indexNode.offsetLeft - indexNode.width / 2;
      while (indexNode = indexNode.parentNode) {
        mouseX -= indexNode.offsetLeft;
      }
      return mouseX;
    };

    Greenhorn.getMouseY = function() {
      var indexNode, mouseY;
      indexNode = _elmnts.canvas;
      mouseY = indexNode.mouseY - indexNode.offsetTop - indexNode.height / 2;
      while (indexNode = indexNode.parentNode) {
        mouseY -= indexNode.offsetTop;
      }
      return mouseY;
    };

    Greenhorn.addButton = function(config) {
      var button, value, _ref1;
      if (config == null) {
        config = {};
      }
      _ref1 = env.BUTTON_DEFAULT_CONFIG;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        value = _ref1[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      button = document.createElement('button');
      button.type = config.type;
      button.innerHTML = config.label;
      button.onclick = config.onclick;
      button.classList.add('gh-button');
      return _elmnts[config.parent].appendChild(button);
    };

    _firstTime = true;

    Greenhorn.isRunning = function() {
      return _masterID != null;
    };

    Greenhorn.stop = function() {
      Sprite._stopAll();
      Sound._pauseAll();
      clearInterval(_masterID);
      return _masterID = null;
    };

    Greenhorn.clear = function() {
      return _elmnts.canvas.getContext('2d').clearRect(-_elmnts.canvas.width / 2, -_elmnts.canvas.height / 2, _elmnts.canvas.width, _elmnts.canvas.height);
    };

    Greenhorn.start = function() {
      var _ctx, _ref1;
      if (!(Greenhorn.isRunning() || (_elmnts.canvas.onclick != null))) {
        if (_firstTime) {
          ((_ref1 = document.querySelector('.gh')) != null ? _ref1 : document.body).appendChild(_elmnts.main);
          if (_elmnts.main.parentNode === document.body) {
            document.body.classList.add('gh');
          }
          _elmnts.title.innerHTML = document.title;
          _elmnts.leftPanelHeader.innerHTML = env.ENGINE.leftHeader;
          _elmnts.rightPanelHeader.innerHTML = env.ENGINE.rightHeader;
          _elmnts.footer.innerHTML = env.ENGINE.footer;
          _elmnts.canvas.innerHTML = 'Your browser does not support the &ltcanvas&gt tag';
          _elmnts.canvas.width = _elmnts.canvas.clientWidth;
          _elmnts.canvas.height = _elmnts.canvas.clientHeight;
          _elmnts.canvas.getContext('2d').translate(_elmnts.canvas.width / 2, _elmnts.canvas.height / 2);
          _ctx = _elmnts.canvas.getContext('2d');
          _ctx.save();
          _ctx.globalAlpha = 1.0;
          _ctx.textAlign = 'center';
          _ctx.textBaseline = 'middle';
          _ctx.font = "" + env.STARTUP.size + "px " + env.STARTUP.font;
          _ctx.fillStyle = env.STARTUP.color;
          _ctx.fillText(env.STARTUP.text, 0, 0);
          _ctx.restore();
          _elmnts.canvas.onclick = function() {
            _startEverything();
            return _elmnts.canvas.onclick = function(e) {
              return Sprite.emitAll('mouse:click');
            };
          };
          return _firstTime = false;
        } else {
          return _startEverything();
        }
      }
    };

    return Greenhorn;

  })();

  gh.Greenhorn = Greenhorn;


  /*
  sprite.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  Sprite = (function() {
    var _boundaryCallback, _bounds, _list, _sortRule;

    _list = [];

    _sortRule = function(sp1, sp2) {
      return sp1._dis.level - sp2._dis.level;
    };

    _bounds = {
      top: document.getElementById('gh-canvas').height / 2,
      bottom: -document.getElementById('gh-canvas').height / 2,
      right: document.getElementById('gh-canvas').width / 2,
      left: -document.getElementById('gh-canvas').width / 2
    };

    _boundaryCallback = function(boundAction, side) {
      switch (boundAction) {
        case 'DIE':
          return function() {
            return this._dis.visible = false;
          };
        case 'WRAP':
          switch (side) {
            case 'top':
              return function() {
                return this.set('top', _bounds.bottom);
              };
            case 'bottom':
              return function() {
                return this.set('bottom', _bounds.top);
              };
            case 'right':
              return function() {
                return this.set('right', _bounds.left);
              };
            case 'left':
              return function() {
                return this.set('left', _bounds.right);
              };
          }
          break;
        case 'STOP':
          switch (side) {
            case 'top':
              return function() {
                return this.set('top', _bounds.top - 1);
              };
            case 'bottom':
              return function() {
                return this.set('bottom', _bounds.bottom + 1);
              };
            case 'right':
              return function() {
                return this.set('right', _bounds.right - 1);
              };
            case 'left':
              return function() {
                return this.set('left', _bounds.left + 1);
              };
          }
          break;
        case 'SPRING':
          switch (side) {
            case 'top':
              return function() {
                return this.change('dy', env.SPRING_CONSTANT * (_bounds.top - this.get('top')));
              };
            case 'bottom':
              return function() {
                return this.change('dy', env.SPRING_CONSTANT * (_bounds.bottom - this.get('bottom')));
              };
            case 'right':
              return function() {
                return this.change('dx', env.SPRING_CONSTANT * (_bounds.right - this.get('right')));
              };
            case 'left':
              return function() {
                return this.change('dx', env.SPRING_CONSTANT * (_bounds.left - this.get('left')));
              };
          }
          break;
        case 'BOUNCE':
          switch (side) {
            case 'top':
              return function() {
                this.set('top', _bounds.top - 1);
                return this._mot.dy *= -1 + env.BOUNCE_DECAY;
              };
            case 'bottom':
              return function() {
                this.set('bottom', _bounds.bottom + 1);
                return this._mot.dy *= -1 + env.BOUNCE_DECAY;
              };
            case 'right':
              return function() {
                this.set('right', _bounds.right - 1);
                return this._mot.dx *= -1 + env.BOUNCE_DECAY;
              };
            case 'left':
              return function() {
                this.set('left', _bounds.left + 1);
                return this._mot.dx *= -1 + env.BOUNCE_DECAY;
              };
          }
      }
    };

    Sprite.howMany = function() {
      return _list.length;
    };

    Sprite.getAll = function() {
      var excep, sp, what, _i, _len, _results;
      what = arguments[0], excep = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.get(what));
        }
      }
      return _results;
    };

    Sprite.setAll = function() {
      var excep, sp, to, what, _i, _len;
      what = arguments[0], to = arguments[1], excep = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          sp.set(what, to);
        }
      }
    };

    Sprite.changeAll = function() {
      var excep, sp, step, what, _i, _len;
      what = arguments[0], step = arguments[1], excep = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          sp.change(what, step);
        }
      }
    };

    Sprite.emitAll = function() {
      var args, event, sp, _i, _len;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        sp.emit.apply(sp, [event].concat(__slice.call(args)));
      }
    };

    Sprite.remove = function(sprite) {
      var i, sp, _i, _len;
      if (sprite.isRunning()) {
        sprite._stop();
      }
      for (i = _i = 0, _len = _list.length; _i < _len; i = ++_i) {
        sp = _list[i];
        if (!(sp === sprite)) {
          continue;
        }
        _list.splice(i, 1);
        return;
      }
    };

    Sprite.removeAll = function() {
      var excep, sp, _i, _j, _len, _len1;
      excep = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          if (sp.isRunning()) {
            sp._stop();
          }
        }
      }
      _list = [];
      for (_j = 0, _len1 = excep.length; _j < _len1; _j++) {
        sp = excep[_j];
        _list.push(sp);
      }
      _list.sort(_sortRule);
    };

    Sprite._drawAll = function() {
      var sp, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        sp._draw();
      }
    };

    Sprite._startAll = function() {
      var sp, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        sp._start();
      }
    };

    Sprite._stopAll = function() {
      var sp, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        sp._stop();
      }
    };

    function Sprite(config) {
      var angles, key, magnitudes, value, _ref;
      if (config == null) {
        config = {};
      }
      this._update = __bind(this._update, this);
      _ref = env.SPRITE_DEFAULT_CONFIG;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      magnitudes = {};
      angles = {};
      for (key in config) {
        if (!__hasProp.call(config, key)) continue;
        value = config[key];
        if (key.match(/(^distance$|^speed$|^rate$)/i)) {
          delete config[key];
          magnitudes[key] = value;
        } else if (key.match(/(^posAngle$|^motAngle$|^accAngle$)/)) {
          delete config[key];
          angles[key] = value;
        }
      }
      this._updateID = null;
      this._dis = {};
      this._pos = {};
      this._mot = {};
      this._acc = {};
      this._bas = {};
      this._dis.image = new Image();
      this._dis.context = document.getElementById('gh-canvas').getContext('2d');
      this.set('config', config);
      this.set('config', magnitudes);
      this.set('config', angles);
      if (Greenhorn.isRunning()) {
        this._start();
      }
      _list.push(this);
      _list.sort(_sortRule);
    }

    Sprite.prototype.isRunning = function() {
      return this._updateID != null;
    };

    Sprite.prototype._start = function() {
      this.emit('start');
      return this._updateID = setInterval(this._update, 1000 / env.FRAME_RATE);
    };

    Sprite.prototype._stop = function() {
      this.emit('stop');
      clearInterval(this._updateID);
      return this._updateID = null;
    };

    Sprite.prototype.get = function(what) {
      var value;
      if (what.match(/^imageFile$/)) {
        value = this._dis.image.src;
      } else if (what.match(/(^x$|^y$|^a$)/)) {
        value = this._pos[what];
      } else if (what.match(/(^dx$|^dy$|^da$)/)) {
        value = this._mot[what];
      } else if (what.match(/(^ddx$|^ddy$|^dda$)/)) {
        value = this._acc[what];
      } else if (what.match(/^top$/)) {
        value = this._pos.y + this._dis.height / 2;
      } else if (what.match(/^bottom$/)) {
        value = this._pos.y - this._dis.height / 2;
      } else if (what.match(/^right$/)) {
        value = this._pos.x + this._dis.width / 2;
      } else if (what.match(/^left$/)) {
        value = this._pos.x - this._dis.width / 2;
      } else if (what.match(/^distance$/)) {
        value = Math.sqrt(Math.pow(this._pos.x, 2) + Math.pow(this._pos.y, 2));
      } else if (what.match(/^speed$/)) {
        value = Math.sqrt(Math.pow(this._mot.dx, 2) + Math.pow(this._mot.dy, 2));
      } else if (what.match(/^rate$/)) {
        value = Math.sqrt(Math.pow(this._acc.ddx, 2) + Math.pow(this._acc.ddy, 2));
      } else if (what.match(/^posAngle$/)) {
        value = Math.atan2(this._pos.y, this._pos.x);
      } else if (what.match(/^motAngle$/)) {
        value = Math.atan2(this._mot.dy, this._mot.dx);
      } else if (what.match(/^accAngle$/)) {
        value = Math.atan2(this._acc.ddy, this._acc.ddx);
      } else if (what.match(/(^level$|^width$|^height$|^visible$)/)) {
        value = this._dis[what];
      } else if (what.match(/^ba_(top|bottom|right|left)/)) {
        value = this._bas[what.split('_')[1]].ba;
      } else {
        throw new Error("" + what + " is not a get-able Sprite attribute");
      }
      this.emit("get:" + what);
      return value;
    };

    Sprite.prototype.set = function(what, to) {
      var k, newCollision, oldCollision, proxy, side, v;
      if (what.match(/(^x$|^y$|^a$)/)) {
        this._pos[what] = to;
      } else if (what.match(/(^dx$|^dy$|^da$)/)) {
        this._mot[what] = to;
      } else if (what.match(/(^ddx$|^ddy$|^dda$)/)) {
        this._acc[what] = to;
      } else if (what.match(/^top$/)) {
        this._pos.y = to - this._dis.height / 2;
      } else if (what.match(/^bottom$/)) {
        this._pos.y = to + this._dis.height / 2;
      } else if (what.match(/^right$/)) {
        this._pos.x = to - this._dis.width / 2;
      } else if (what.match(/^left$/)) {
        this._pos.x = to + this._dis.width / 2;
      } else if (what.match(/^imageFile$/)) {
        if (env.IMAGE_PATH.match(/\/$/)) {
          this._dis.image.src = env.IMAGE_PATH.concat(to);
        } else {
          if (env.IMAGE_PATH) {
            env.IMAGE_PATH += '/';
            this._dis.image.src = env.IMAGE_PATH.concat(to);
          } else {
            this._dis.image.src = to;
          }
        }
      } else if (what.match(/^distance$/)) {
        proxy = {
          x: to * Math.cos(this.get('posAngle')),
          y: to * Math.sin(this.get('posAngle'))
        };
        this.set('_pos', proxy);
      } else if (what.match(/^speed$/)) {
        proxy = {
          dx: to * Math.cos(this.get('motAngle')),
          dy: to * Math.sin(this.get('motAngle'))
        };
        this.set('_mot', proxy);
      } else if (what.match(/^rate$/)) {
        proxy = {
          ddx: to * Math.cos(this.get('accAngle')),
          ddy: to * Math.sin(this.get('accAngle'))
        };
        this.set('_acc', proxy);
      } else if (what.match(/^posAngle$/)) {
        proxy = {
          x: this.get('distance') * Math.cos(to),
          y: this.get('distance') * Math.sin(to)
        };
        this.set('_pos', proxy);
      } else if (what.match(/^motAngle$/)) {
        proxy = {
          dx: this.get('speed') * Math.cos(to),
          dy: this.get('speed') * Math.sin(to)
        };
        this.set('_mot', proxy);
      } else if (what.match(/^accAngle$/)) {
        proxy = {
          ddx: this.get('rate') * Math.cos(to),
          ddy: this.get('rate') * Math.sin(to)
        };
        this.set('_acc', proxy);
      } else if (what.match(/(^_?dis|^_?pos|^_?mot|^_?acc|^config)/)) {
        for (k in to) {
          if (!__hasProp.call(to, k)) continue;
          v = to[k];
          this.set(k, v);
        }
      } else if (what.match(/(^level$|^width$|^height$|^visible$)/)) {
        this._dis[what] = to;
        if (what === 'level') {
          _list.sort(_sortRule);
        }
      } else if (what.match(/^ba_(all|top|bottom|right|left)$/)) {
        side = what.split('_')[1];
        oldCollision = this._bas[side] != null ? this._bas[side].ba.match(/(DIE|WRAP)/) ? 'off' : 'hit' : '';
        newCollision = (function() {
          if (to.match(/(DIE|WRAP)/)) {
            return 'off';
          } else if (to.match(/(STOP|SPRING|BOUNCE)/)) {
            return 'hit';
          } else {
            throw new Error("" + to + " is not a valid boundary action");
          }
        })();
        if (side !== 'all') {
          if (this._bas[side] != null) {
            this.remove("" + oldCollision + ":" + side, this._bas[side]);
          }
          this._bas[side] = _boundaryCallback(to, side);
          this._bas[side].ba = to;
          this.on("" + newCollision + ":" + side, this._bas[side]);
        } else {
          proxy = {
            ba_top: to,
            ba_bottom: to,
            ba_right: to,
            ba_left: to
          };
          this.set('config', proxy);
        }
      } else {
        throw new Error("" + what + " is not a set-able Sprite attribute");
      }
      this.emit("set:" + what, to);
      return this;
    };

    Sprite.prototype.change = function(what, step) {
      var k, proxy, v;
      if (what.match(/(^x$|^y$|^a$)/)) {
        this._pos[what] += step / env.FRAME_RATE;
      } else if (what.match(/(^dx$|^dy$|^da$)/)) {
        this._mot[what] += step / env.FRAME_RATE;
      } else if (what.match(/(^ddx$|^ddy$|^dda$)/)) {
        this._acc[what] += step / env.FRAME_RATE;
      } else if (what.match(/(^level$|^width$|^height$)/)) {
        this._dis[what] += step / env.FRAME_RATE;
      } else if (what.match(/^distance$/)) {
        proxy = {
          dx: step * Math.cos(this.get('posAngle')),
          dy: step * Math.sin(this.get('posAngle'))
        };
        this.change('_pos', proxy);
      } else if (what.match(/^speed$/)) {
        proxy = {
          ddx: step * Math.cos(this.get('motAngle')),
          ddy: step * Math.sin(this.get('motAngle'))
        };
        this.change('_mot', proxy);
      } else if (what.match(/^rate$/)) {
        proxy = {
          dddx: step * Math.cos(this.get('accAngle')),
          dddy: step * Math.sin(this.get('accAngle'))
        };
        this.change('_acc', proxy);
      } else if (what.match(/^posAngle$/)) {
        proxy = {
          dx: this.get('distance') * Math.cos(step),
          dy: this.get('distance') * Math.sin(step)
        };
        this.change('_pos', proxy);
      } else if (what.match(/^motAngle$/)) {
        proxy = {
          ddx: this.get('speed') * Math.cos(step),
          ddy: this.get('speed') * Math.sin(step)
        };
        this.change('_mot', proxy);
      } else if (what.match(/^accAngle$/)) {
        proxy = {
          dddx: this.get('rate') * Math.cos(step),
          dddy: this.get('rate') * Math.sin(step)
        };
        this.change('_acc', proxy);
      } else if (what.match(/(^_?dis|^_?pos|^_?mot|^_?acc)/)) {
        for (k in step) {
          if (!__hasProp.call(step, k)) continue;
          v = step[k];
          this.change(k.slice(1), v);
        }
      } else {
        throw new Error("" + what + " is not a change-able Sprite attribute");
      }
      this.emit("change:" + what, step);
      return this;
    };

    Sprite.prototype.collidesWith = function(other) {
      var collision, _ref, _ref1;
      if (other === 'mouse') {
        collision = false;
        if (this._dis.visible) {
          if ((this.get('left') < (_ref = Greenhorn.getMouseX()) && _ref < this.get('right')) && (this.get('bottom') < (_ref1 = Greenhorn.getMouseY()) && _ref1 < this.get('top'))) {
            collision = true;
          }
        }
      } else {
        collision = true;
        if (this._dis.visible && other.get('visible') && this._dis.level === other.get('level')) {
          if (this.get('bottom') > other.get('top') || this.get('top') < other.get('bottom') || this.get('right') < other.get('left') || this.get('left') > other.get('right')) {
            collision = false;
          }
        } else {
          collision = false;
        }
      }
      return collision;
    };

    Sprite.prototype.distanceTo = function(other) {
      var otherX, otherY;
      otherX = otherY = 0;
      if (other === 'mouse') {
        otherX = Greenhorn.getMouseX();
        otherY = Greenhorn.getMouseY();
      } else {
        otherX = other.get('x');
        otherY = other.get('y');
      }
      return Math.sqrt(Math.pow(this._pos.x - otherX, 2) + Math.pow(this._pos.y - otherY, 2));
    };

    Sprite.prototype.angleTo = function(other) {
      var otherX, otherY;
      otherX = otherY = 0;
      if (other === 'mouse') {
        otherX = Greenhorn.getMouseX();
        otherY = Greenhorn.getMouseY();
      } else {
        otherX = other.get('x');
        otherY = other.get('y');
      }
      return Math.atan2(this._pos.y - otherY, this._pos.x - otherX);
    };

    Sprite.prototype._draw = function() {
      if (this._dis.visible) {
        this.emit('draw');
        this._dis.context.save();
        this._dis.context.translate(this._pos.x, -this._pos.y);
        this._dis.context.rotate(-this._pos.a);
        this._dis.context.drawImage(this._dis.image, -this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
        return this._dis.context.restore();
      }
    };

    Sprite.prototype._update = function() {
      var event, key, keys, listeners, token, tokens, _emit, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
      this.emit('update');
      this.change('_mot', this._acc);
      this.change('_pos', this._mot);
      if (this.get('bottom') > _bounds.top) {
        this.emit('off:top');
      }
      if (this.get('top') < _bounds.bottom) {
        this.emit('off:bottom');
      }
      if (this.get('left') > _bounds.right) {
        this.emit('off:right');
      }
      if (this.get('right') < _bounds.left) {
        this.emit('off:left');
      }
      if (this.get('top') >= _bounds.top) {
        this.emit('hit:top');
      }
      if (this.get('bottom') <= _bounds.bottom) {
        this.emit('hit:bottom');
      }
      if (this.get('right') >= _bounds.right) {
        this.emit('hit:right');
      }
      if (this.get('left') <= _bounds.left) {
        this.emit('hit:left');
      }
      _ref = this._events;
      for (event in _ref) {
        if (!__hasProp.call(_ref, event)) continue;
        listeners = _ref[event];
        if (event.match(/^isDown:(\w+|\d)/)) {
          token = event.split(':')[1].toUpperCase();
          if (token.match(/-/)) {
            _emit = false;
            keys = token.split('-');
            for (_i = 0, _len = keys.length; _i < _len; _i++) {
              key = keys[_i];
              if (Greenhorn.isDown[KEYS[key]]) {
                _emit = true;
              }
            }
            if (_emit) {
              this.emit(event);
            }
          } else if (token.match(/\+/)) {
            _emit = true;
            keys = token.split('+');
            for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
              key = keys[_j];
              if (!Greenhorn.isDown[KEYS[key]]) {
                _emit = false;
              }
            }
            if (_emit) {
              this.emit(event);
            }
          } else {
            if (Greenhorn.isDown[KEYS[token]]) {
              this.emit(event);
            }
          }
        } else if (event.match(/^isUp:(\w+|\d)$/)) {
          token = event.split(':')[1].toUpperCase();
          if (token.match(/-/)) {
            _emit = false;
            keys = token.split('-');
            for (_k = 0, _len2 = keys.length; _k < _len2; _k++) {
              key = keys[_k];
              if (!Greenhorn.isDown[KEYS[key]]) {
                _emit = true;
              }
            }
            if (_emit) {
              this.emit(event);
            }
          } else if (token.match(/\+/)) {
            _emit = true;
            keys = token.split('+');
            for (_l = 0, _len3 = keys.length; _l < _len3; _l++) {
              key = keys[_l];
              if (Greenhorn.isDown[KEYS[key]]) {
                _emit = false;
              }
            }
            if (_emit) {
              this.emit(event);
            }
          } else {
            if (!Greenhorn.isDown[KEYS[token]]) {
              this.emit(event);
            }
          }
        } else if (event.match(/^collisionWith:\w+/)) {
          if (this.collidesWith(listeners.other)) {
            this.emit(event, listeners.other);
          }
        } else if (event.match(/^distanceTo:\w+-(gt|lt|eq|ge|le|ne)-\d*\.?\d*$/)) {
          tokens = event.split(':')[1];
          tokens = tokens.split('-');
          tokens[2] = parseFloat(tokens[2]);
          switch (tokens[1]) {
            case 'gt':
              if (this.distanceTo(listeners.other) > tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'lt':
              if (this.distanceTo(listeners.other) < tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'eq':
              if (this.distanceTo(listeners.other) === tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'ge':
              if (this.distanceTo(listeners.other) >= tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'le':
              if (this.distanceTo(listeners.other) <= tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'ne':
              if (this.distanceTo(listeners.other) !== tokens[2]) {
                this.emit(event, listeners.other);
              }
          }
        } else if (event.match(/^angleTo:\w+-(gt|lt|eq|ge|le|ne)-\d*\.?\d*$/)) {
          tokens = event.split(':')[1];
          tokens = tokens.split('-');
          tokens[2] = parseFloat(tokens[2]);
          switch (tokens[1]) {
            case 'gt':
              if (this.angleTo(listeners.other) > tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'lt':
              if (this.angleTo(listeners.other) < tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'eq':
              if (this.angleTo(listeners.other) === tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'ge':
              if (this.angleTo(listeners.other) >= tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'le':
              if (this.angleTo(listeners.other) <= tokens[2]) {
                this.emit(event, listeners.other);
              }
              break;
            case 'ne':
              if (this.angleTo(listeners.other) !== tokens[2]) {
                this.emit(event, listeners.other);
              }
          }
        } else if (event.match(/^\w+-(gt|lt|eq|ge|le|ne)-\d*\.?\d*$/)) {
          tokens = event.split('-');
          tokens[2] = parseFloat(tokens[2]);
          switch (tokens[1]) {
            case 'gt':
              if (this.get(tokens[0]) > tokens[2]) {
                this.emit(event);
              }
              break;
            case 'lt':
              if (this.get(tokens[0]) < tokens[2]) {
                this.emit(event);
              }
              break;
            case 'eq':
              if (this.get(tokens[0]) === tokens[2]) {
                this.emit(event);
              }
              break;
            case 'ge':
              if (this.get(tokens[0]) >= tokens[2]) {
                this.emit(event);
              }
              break;
            case 'le':
              if (this.get(tokens[0]) <= tokens[2]) {
                this.emit(event);
              }
              break;
            case 'ne':
              if (this.get(tokens[0]) !== tokens[2]) {
                this.emit(event);
              }
          }
        }
      }
      return this;
    };

    Sprite.prototype.report = function() {
      return "position:\n    x: " + (this._pos.x.toFixed(2)) + "\n    y: " + (this._pos.y.toFixed(2)) + "\n    a: " + (this._pos.a.toFixed(2)) + "\nmotion:\n    dx: " + (this._mot.dx.toFixed(2)) + "\n    dy: " + (this._mot.dy.toFixed(2)) + "\n    da: " + (this._mot.da.toFixed(2)) + "\nacceleration:\n    ddx: " + (this._acc.ddx.toFixed(2)) + "\n    ddy: " + (this._acc.ddy.toFixed(2)) + "\n    dda: " + (this._acc.dda.toFixed(2)) + "\ndisplay:\n    level: " + (Math.round(this._dis.level)) + "\n    width: " + (Math.round(this._dis.width)) + "\n    height: " + (Math.round(this._dis.height)) + "\n    visible: " + this._dis.visible + "\n    boundAction: " + this._dis.boundAction;
    };

    Sprite.prototype.log = function() {
      console.log(this.report());
    };

    return Sprite;

  })();

  _mixin(Sprite.prototype, EventEmitter.prototype);

  gh.Sprite = Sprite;


  /*
  aniSprite.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  AniCycle = (function() {
    function AniCycle(data) {
      this.frame = data.start;
      this.index = data.index;
      this.start = data.start;
      this.stop = data.stop;
      this.name = data.name;
    }

    return AniCycle;

  })();

  AniSprite = (function(_super) {
    __extends(AniSprite, _super);

    function AniSprite(config) {
      var initialCycle, key, value, _ref;
      if (config == null) {
        config = {};
      }
      _ref = env.ANISPRITE_DEFAULT_CONFIG;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      initialCycle = null;
      for (key in config) {
        if (!__hasProp.call(config, key)) continue;
        value = config[key];
        if (key.match(/(^current$|^animation$)/i)) {
          delete config[key];
          initialCycle = value;
        }
      }
      this._ani = {};
      this._ani.cycles = [];
      this._ani.timer = new Timer(true);
      AniSprite.__super__.constructor.call(this, config);
      if (initialCycle != null) {
        this.set('current', initialCycle);
      }
    }

    AniSprite.prototype.get = function(what) {
      var value, _emit;
      _emit = true;
      if (what.match(/(^current$|^animation$)/)) {
        value = this._ani.current.name;
      } else if (what.match(/(^cellWidth$|^cellHeight$|^frameRate$|^orientation$)/)) {
        value = this._ani[what];
      } else {
        value = AniSprite.__super__.get.call(this, what);
        _emit = false;
      }
      if (_emit) {
        this.emit("get:" + what);
      }
      return value;
    };

    AniSprite.prototype.set = function(what, to) {
      var cycle, _base, _emit, _i, _len, _ref, _ref1;
      _emit = true;
      if (what.match(/(^current$|^animation$)/)) {
        if (to !== this._ani.current.name) {
          this._ani.current.frame = this._ani.current.start;
          _ref = this._ani.cycles;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            cycle = _ref[_i];
            if (cycle.name === to) {
              this._ani.current = cycle;
            }
          }
        }
      } else if (what.match(/(^cellWidth$|^cellHeight$|^frameRate$|^orientation$)/)) {
        this._ani[what] = to;
      } else if (what.match(/^cycle/)) {
        if (to.index == null) {
          to.index = env.ANICYCLE_DEFAULT_CONFIG.index;
        }
        if (to.start == null) {
          to.start = env.ANICYCLE_DEFAULT_CONFIG.start;
        }
        if (to.stop == null) {
          to.stop = to.start + env.ANICYCLE_DEFAULT_CONFIG.numFrames - 1;
        }
        if (to.name == null) {
          to.name = (_ref1 = what.slice(5)) != null ? _ref1 : env.ANICYCLE_DEFAULT_CONFIG.name;
        }
        this._ani.cycles.push(new AniCycle(to));
        if ((_base = this._ani).current == null) {
          _base.current = this._ani.cycles[0];
        }
      } else {
        AniSprite.__super__.set.call(this, what, to);
        _emit = false;
      }
      if (_emit) {
        this.emit("set:" + what, to);
      }
      return this;
    };

    AniSprite.prototype.change = function(what, step) {
      var _emit;
      _emit = true;
      if (what.match(/^frameRate$/)) {
        this._ani.frameRate += step;
      } else {
        AniSprite.__super__.change.call(this, what, step);
        _emit = false;
      }
      if (_emit) {
        this.emit("change:" + what, step);
      }
      return this;
    };

    AniSprite.prototype.play = function() {
      this.emit('play');
      this._ani.timer.start();
      return this;
    };

    AniSprite.prototype.pause = function() {
      this.emit('pause');
      this._ani.timer.pause();
      return this;
    };

    AniSprite.prototype.stop = function() {
      this.emit('stop');
      this._ani.timer.stop();
      this._ani.current.frame = this._ani.current.start;
      return this;
    };

    AniSprite.prototype._draw = function() {
      var sliceX, sliceY;
      if (this._dis.visible) {
        this.emit('draw');
        this._dis.context.save();
        this._dis.context.translate(this._pos.x, -this._pos.y);
        this._dis.context.rotate(-this._pos.a);
        if (this._ani.orientation.toLowerCase() === 'horizontal') {
          sliceX = this._ani.current.frame - 1;
          sliceY = this._ani.current.index - 1;
        } else if (this._ani.orientation.toLowerCase() === 'vertical') {
          sliceX = this._ani.current.index - 1;
          sliceY = this._ani.current.frame - 1;
        }
        this._dis.context.drawImage(this._dis.image, this._ani.cellWidth * sliceX, this._ani.cellHeight * sliceY, this._ani.cellWidth, this._ani.cellHeight, -this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
        return this._dis.context.restore();
      }
    };

    AniSprite.prototype._update = function() {
      AniSprite.__super__._update.call(this);
      if (this._ani.timer.getElapsedTime() >= (1000 / this._ani.frameRate)) {
        if (this._ani.current.frame < this._ani.current.stop) {
          this._ani.current.frame += 1;
        } else {
          this._ani.current.frame = this._ani.current.start;
        }
        return this._ani.timer.restart();
      }
    };

    return AniSprite;

  })(Sprite);

  gh.AniSprite = AniSprite;


  /*
  textSprite.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  TextSprite = (function(_super) {
    __extends(TextSprite, _super);

    function TextSprite(config) {
      var key, value, _ref;
      if (config == null) {
        config = {};
      }
      _ref = env.TEXTSPRITE_DEFAULT_CONFIG;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      this._text = [];
      this._font = {};
      this._border = {};
      this._outline = {};
      this._margins = {};
      this._background = {};
      TextSprite.__super__.constructor.call(this, config);
    }

    TextSprite.prototype.get = function(what) {
      var value, _emit;
      _emit = true;
      if (what.match(/^text$/)) {
        value = this._text.join('\n');
      } else if (what.match(/^font\w+/)) {
        value = this._font[what.slice(4)];
      } else if (what.match(/^border\w+/)) {
        value = this._border[what.slice(6)];
      } else if (what.match(/^outline\w+/)) {
        value = this._outline[what.slice(7)];
      } else if (what.match(/^margins\w+/)) {
        value = this._margins[what.slice(7)];
      } else if (what.match(/^background\w+/)) {
        value = this._background[what.slice(10)];
      } else {
        value = TextSprite.__super__.get.call(this, what);
        _emit = false;
      }
      if (_emit) {
        this.emit("get:" + what);
      }
      return value;
    };

    TextSprite.prototype.set = function(what, to) {
      var k, v, _emit;
      _emit = true;
      if (what.match(/^text$/)) {
        this._text = to.split('\n');
      } else if (what.match(/^font\w+/)) {
        this._font[what.slice(4)] = to;
      } else if (what.match(/^border\w+/)) {
        this._border[what.slice(6)] = to;
      } else if (what.match(/^outline\w+/)) {
        this._outline[what.slice(7)] = to;
      } else if (what.match(/^margins\w+/)) {
        this._margins[what.slice(7)] = to;
      } else if (what.match(/^background\w+/)) {
        this._background[what.slice(10)] = to;
      } else if (what.match(/(^font$|^border$|^outline$|^margins$|^background$)/)) {
        for (k in to) {
          if (!__hasProp.call(to, k)) continue;
          v = to[k];
          this.set(what.concat(k), v);
        }
      } else {
        TextSprite.__super__.set.call(this, what, to);
        _emit = false;
      }
      if (_emit) {
        this.emit("set:" + what, to);
      }
      return this;
    };

    TextSprite.prototype.change = function(what, step) {
      var k, v, _emit;
      _emit = true;
      if (what.match(/^text$/)) {
        this._text = (this._text.join('\n').concat(step)).split('\n');
      } else if (what.match(/^font\w+/)) {
        this._font[what.slice(4)] += step;
      } else if (what.match(/^border\w+/)) {
        this._border[what.slice(6)] += step;
      } else if (what.match(/^outline\w+/)) {
        this._outline[what.slice(7)] += step;
      } else if (what.match(/^margins\w+/)) {
        this._margins[what.slice(7)] += step;
      } else if (what.match(/^background\w+/)) {
        this._background[what.slice(10)] += step;
      } else if (what.match(/(^font$|^border$|^outline$|^margins$|^background$)/i)) {
        for (k in to) {
          if (!__hasProp.call(to, k)) continue;
          v = to[k];
          this.change(what.concat(k), v);
        }
      } else {
        TextSprite.__super__.change.call(this, what, step);
        _emit = false;
      }
      if (_emit) {
        this.emit("change:" + what, step);
      }
      return this;
    };

    TextSprite.prototype._draw = function() {
      var i, line, xOffset, yOffset, _i, _j, _len, _len1, _ref, _ref1;
      if (this._dis.visible) {
        this.emit('draw');
        this._dis.context.save();
        this._dis.context.translate(this._pos.x, -this._pos.y);
        this._dis.context.rotate(-this._pos.a);
        if (this._background.visible) {
          this._dis.context.save();
          this._dis.context.fillStyle = this._background.color;
          this._dis.context.globalAlpha = this._background.alpha;
          this._dis.context.fillRect(-this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
          this._dis.context.restore();
        }
        if (this._border.visible) {
          this._dis.context.save();
          this._dis.context.strokeStyle = this._border.color;
          this._dis.context.lineWidth = this._border.size;
          this._dis.context.globalAlpha = this._border.alpha;
          this._dis.context.strokeRect(-this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
          this._dis.context.restore();
        }
        yOffset = (this._text.length - 1) * this._font.size * .75;
        if (this._font.align.toLowerCase() === 'center') {
          xOffset = 0;
        } else if (this._font.align.toLowerCase() === 'left') {
          xOffset = -this._dis.width / 2 + this._margins.left;
          if (this._border.visible) {
            xOffset += this._border.size;
          }
        } else if (this._font.align.toLowerCase() === 'right') {
          xOffset = this._dis.width / 2 - this._margins.right;
          if (this._border.visible) {
            xOffset -= this._border.size;
          }
        }
        this._dis.context.textBaseline = 'middle';
        this._dis.context.fillStyle = this._font.color;
        this._dis.context.globalAlpha = this._font.alpha;
        this._dis.context.textAlign = "" + this._font.align;
        this._dis.context.font = "" + this._font.size + "px " + this._font.name;
        _ref = this._text;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          line = _ref[i];
          this._dis.context.fillText(line, xOffset, this._font.size * 1.5 * i - yOffset);
        }
        if (this._outline.visible) {
          this._dis.context.lineWidth = this._outline.size;
          this._dis.context.strokeStyle = this._outline.color;
          this._dis.context.globalAlpha = this._outline.alpha;
          _ref1 = this._text;
          for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
            line = _ref1[i];
            this._dis.context.strokeText(line, xOffset, this._font.size * 1.5 * i - yOffset);
          }
        }
        return this._dis.context.restore();
      }
    };

    TextSprite.prototype._update = function() {
      var len, line, _i, _len, _ref;
      TextSprite.__super__._update.call(this);
      this._dis.width = 0;
      this._dis.height = this._font.size * 1.5 * this._text.length;
      this._dis.context.save();
      this._dis.context.font = "" + this._font.size + "px " + this._font.name;
      _ref = this._text;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        len = this._dis.context.measureText(line).width;
        if (this._dis.width < len) {
          this._dis.width = len;
        }
      }
      this._dis.context.restore();
      this._dis.width += this._margins.left + this._margins.right;
      this._dis.height += this._margins.top + this._margins.bottom;
      if (this._border.visible) {
        this._dis.width += 2 * this._border.size;
        return this._dis.height += 2 * this._border.size;
      }
    };

    return TextSprite;

  })(Sprite);

  gh.TextSprite = TextSprite;


  /*
  timer.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  Timer = (function() {
    function Timer(start_now) {
      if (start_now == null) {
        start_now = env.TIMER_START_ON_CONSTRUCTION;
      }
      this._elapsedTime = 0;
      this._startTime = start_now ? this.getCurrentTime() : null;
      return this;
    }

    Timer.prototype.getStartTime = function() {
      return this._startTime;
    };

    Timer.prototype.getCurrentTime = function() {
      return (new Date()).getTime();
    };

    Timer.prototype.getElapsedTime = function() {
      if (!this._startTime) {
        return this._elapsedTime;
      } else {
        return this._elapsedTime + this.getCurrentTime() - this._startTime;
      }
    };

    Timer.prototype.start = function() {
      if (!this._startTime) {
        this._startTime = this.getCurrentTime();
      }
    };

    Timer.prototype.pause = function() {
      if (this._startTime) {
        this._elapsedTime += this.getCurrentTime() - this.getStartTime();
        this._startTime = null;
      }
    };

    Timer.prototype.restart = function() {
      this._elapsedTime = 0;
      this._startTime = this.getCurrentTime();
    };

    Timer.prototype.stop = function() {
      this._elapsedTime = 0;
      this._startTime = null;
    };

    return Timer;

  })();

  gh.Timer = Timer;


  /*
  sound.coffee
  Written by Seth Bullock
  sedabull@gmail.com
   */

  if ((window.AudioContext != null) || (window.webkitAudioContext != null)) {
    AudioContext = (_ref = window.AudioContext) != null ? _ref : window.webkitAudioContext;
    _audioContext = new AudioContext();
  } else {
    env.USE_AUDIO_TAG = true;
  }

  Sound = (function() {
    var _list;

    _list = [];

    Sound._playAll = function() {
      var snd, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        snd = _list[_i];
        if (snd._config.autoplay) {
          snd.play();
        } else {
          snd.play({
            volume: 0,
            loop: false
          });
          setTimeout(snd.stop, 50);
        }
      }
    };

    Sound._pauseAll = function() {
      var snd, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        snd = _list[_i];
        snd.pause();
      }
    };

    Sound._stopAll = function() {
      var snd, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        snd = _list[_i];
        snd.stop();
      }
    };

    function Sound(_config) {
      var key, mp3_src, ogg_src, request, value, wav_src, _base, _ref1;
      this._config = _config != null ? _config : {};
      this.stop = __bind(this.stop, this);
      this.pause = __bind(this.pause, this);
      this.restart = __bind(this.restart, this);
      this.play = __bind(this.play, this);
      _ref1 = env.SOUND_DEFAULT_CONFIG;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        value = _ref1[key];
        if ((_base = this._config)[key] == null) {
          _base[key] = value;
        }
      }
      if (env.SOUND_PATH.match(/\/$/)) {
        this._config.url = env.SOUND_PATH.concat(this._config.url);
      } else {
        if (env.SOUND_PATH) {
          env.SOUND_PATH += '/';
          this._config.url = env.SOUND_PATH.concat(this._config.url);
        }
      }
      if (env.USE_AUDIO_TAG) {
        this._audio = document.createElement('audio');
        mp3_src = document.createElement('source');
        ogg_src = document.createElement('source');
        wav_src = document.createElement('source');
        mp3_src.type = 'audio/mpeg';
        ogg_src.type = 'audio/ogg';
        wav_src.type = 'audio/wav';
        if (this._config.url.match(/\.mp3$/)) {
          mp3_src.src = this._config.url;
          ogg_src.src = this._config.url.replace('.mp3', '.ogg');
          wav_src.src = this._config.url.replace('.mp3', '.wav');
        } else if (this._config.url.match(/\.ogg$/)) {
          ogg_src.src = this._config.url;
          mp3_src.src = this._config.url.replace('.ogg', '.mp3');
          wav_src.src = this._config.url.replace('.ogg', '.wav');
        } else if (this._config.url.match(/\.wav$/)) {
          wav_src.src = this._config.url;
          mp3_src.src = this._config.url.replace('.wav', '.mp3');
          ogg_src.src = this._config.url.replace('.wav', '.ogg');
        } else {
          throw new Error("Only .mp3, .ogg, and .wav file extensions are supported by the audio tag");
        }
        this._audio.appendChild(mp3_src);
        this._audio.appendChild(ogg_src);
        this._audio.appendChild(wav_src);
        if (Greenhorn.isRunning() && this._config.autoplay) {
          this._audio.autoplay = true;
        }
      } else {
        this._source = null;
        this._buffer = null;
        this._isEnded = true;
        this._startTime = 0;
        this._elapsedTime = 0;
        request = new XMLHttpRequest();
        request.open('GET', this._config.url, true);
        request.responseType = 'arraybuffer';
        request.successCallback = (function(_this) {
          return function(buffer) {
            _this._buffer = buffer;
            if (Greenhorn.isRunning() && _this._config.autoplay) {
              return _this.play();
            }
          };
        })(this);
        request.errorCallback = function() {
          throw new Error("AJAX request Error");
        };
        request.onload = function() {
          return _audioContext.decodeAudioData(this.response, this.successCallback, this.errorCallback);
        };
        request.send();
      }
      _list.push(this);
    }

    Sound.prototype.play = function(opt) {
      var gainNode, _ref1, _ref2, _ref3, _ref4;
      if (opt == null) {
        opt = {};
      }
      if (Greenhorn.isRunning()) {
        if (env.USE_AUDIO_TAG) {
          this._audio.loop = (_ref1 = opt.loop) != null ? _ref1 : this._config.loop;
          this._audio.volume = (_ref2 = opt.volume) != null ? _ref2 : this._config.volume;
          return this._audio.play();
        } else {
          if (this._isEnded) {
            this._isEnded = false;
            gainNode = _audioContext.createGain();
            this._source = _audioContext.createBufferSource();
            this._source.buffer = this._buffer;
            this._source.loop = (_ref3 = opt.loop) != null ? _ref3 : this._config.loop;
            this._source.onended = (function(_this) {
              return function() {
                _this._isEnded = true;
                _this._elapsedTime += _audioContext.currentTime - _this._startTime;
                if (_this._elapsedTime >= _this._buffer.duration) {
                  return _this._elapsedTime = 0;
                }
              };
            })(this);
            gainNode.gain.value = (_ref4 = opt.volume) != null ? _ref4 : this._config.volume;
            this._source.connect(gainNode);
            gainNode.connect(_audioContext.destination);
            this._startTime = _audioContext.currentTime;
            return this._source.start(this._startTime, this._elapsedTime);
          }
        }
      }
    };

    Sound.prototype.restart = function(opt) {
      var gainNode, _ref1, _ref2, _ref3, _ref4;
      if (opt == null) {
        opt = {};
      }
      if (Greenhorn.isRunning()) {
        if (env.USE_AUDIO_TAG) {
          this._audio.currentTime = 0;
          this._audio.loop = (_ref1 = opt.loop) != null ? _ref1 : this._config.loop;
          this._audio.volume = (_ref2 = opt.volume) != null ? _ref2 : this._config.volume;
          return this._audio.play();
        } else {
          this._source.stop();
          this._elapsedTime = 0;
          gainNode = _audioContext.createGain();
          this._source = _audioContext.createBufferSource();
          this._source.buffer = this._buffer;
          this._source.loop = (_ref3 = opt.loop) != null ? _ref3 : this._config.loop;
          this._source.onended = (function(_this) {
            return function() {
              _this._isEnded = true;
              return _this._elapsedTime = 0;
            };
          })(this);
          gainNode.gain.value = (_ref4 = opt.volume) != null ? _ref4 : this._config.volume;
          this._source.connect(gainNode);
          gainNode.connect(_audioContext.destination);
          this._startTime = _audioContext.currentTime;
          return this._source.start(this._startTime, this._elapsedTime);
        }
      }
    };

    Sound.prototype.pause = function() {
      if (Greenhorn.isRunning()) {
        if (env.USE_AUDIO_TAG) {
          return this._audio.pause();
        } else {
          return this._source.stop();
        }
      }
    };

    Sound.prototype.stop = function() {
      if (Greenhorn.isRunning()) {
        if (env.USE_AUDIO_TAG) {
          this._audio.pause();
          return this._audio.currentTime = 0;
        } else {
          this._source.stop();
          return this._elapsedTime = 0;
        }
      }
    };

    return Sound;

  })();

  gh.Sound = Sound;

}).call(this);
