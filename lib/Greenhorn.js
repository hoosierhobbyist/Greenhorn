// Generated by CoffeeScript 1.8.0

/*
environment.coffee

The Greenhorn Gaming environment object
 */

(function() {
  var AniCycle, AudioContext, key, makeSortRule, _audioContext, _masterID, _masterUpdate, _ref,
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.env = {
    FRAME_RATE: 25,
    BODY_BACKGROUND_COLOR: "goldenrod",
    ENGINE_LEFT_PANEL: "LEFT PANEL",
    ENGINE_RIGHT_PANEL: "RIGHT PANEL",
    ENGINE_BOTTOM_PANEL: "BOTTOM PANEL",
    ENGINE_CANVAS_COLOR: "black",
    ENGINE_BACKGROUND_COLOR: "darkgreen",
    IMAGE_PATH: "",
    SPRITE_DEFAULT_CONFIG: {
      x: 0,
      y: 0,
      z: 0,
      a: 0,
      dx: 0,
      dy: 0,
      dz: 0,
      da: 0,
      ddx: 0,
      ddy: 0,
      ddz: 0,
      dda: 0,
      width: 64,
      height: 64,
      imageFile: "",
      visible: true,
      boundAction: "WRAP"
    },
    TEXTBOX_DEFAULT_CONFIG: {
      z: -1,
      text: "*-TextBox-*",
      align: "center",
      backgroundColor: "black",
      backgroundAlpha: 1.0,
      backgroundVisible: true,
      borderSize: 5,
      borderColor: "white",
      borderAlpha: 1.0,
      borderVisible: true,
      fontName: "Arial",
      fontSize: 8,
      fontColor: "white",
      fontAlpha: 1.0,
      marginsTop: 5,
      marginsBottom: 5,
      marginsRight: 5,
      marginsLeft: 5
    },
    ANISPRITE_DEFAULT_CONFIG: {
      sheetWidth: 256,
      sheetHeight: 256,
      cellWidth: 32,
      cellHeight: 32,
      frameRate: 5,
      numFrames: 8
    },
    SOUND_PATH: "",
    USE_AUDIO_TAG: false,
    SOUND_DEFAULT_CONFIG: {
      url: "",
      playOnLoad: false
    },
    TIMER_START_ON_CONSTRUCTION: true,
    BUTTON_DEFAULT_LABEL: "Launch the Missiles!"
  };


  /*
  greenhorn.coffee
  by Seth Bullock
  
  ***THE GREENHORN GAMING ENGINE***
  
  primarily inspired by Andy Harris'
  (aharrisbooks.net) simpleGame.js gaming engine
   */

  this.KEYS = {
    LEFT: 37,
    RIGHT: 39,
    UP: 38,
    DOWN: 40,
    SPACE: 32,
    ESC: 27,
    PGUP: 33,
    PGDOWN: 34,
    HOME: 36,
    END: 35,
    _0: 48,
    _1: 49,
    _2: 50,
    _3: 51,
    _4: 52,
    _5: 53,
    _6: 54,
    _7: 55,
    _8: 56,
    _9: 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90
  };

  this.keysDown = (function() {
    var _i, _len, _ref, _results;
    _ref = new Array(256);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      _results.push(key = false);
    }
    return _results;
  })();

  document.onkeydown = function(e) {
    e.preventDefault();
    return keysDown[e.keyCode] = true;
  };

  document.onkeyup = function(e) {
    e.preventDefault();
    return keysDown[e.keyCode] = false;
  };

  document.onmousemove = function(e) {
    this.mouseX = e.pageX;
    return this.mouseY = e.pageY;
  };

  _masterID = null;

  _masterUpdate = function() {
    Greenhorn.clear();
    if (typeof update === "function") {
      update();
    }
    return Sprites._drawAll();
  };

  this.Greenhorn = (function() {
    function Greenhorn() {}

    Greenhorn._elmnts = {
      main: document.createElement("div"),
      title: document.createElement("h2"),
      leftPanel: document.createElement("div"),
      canvas: document.createElement("canvas"),
      rightPanel: document.createElement("div"),
      bottomPanel: document.createElement("div")
    };

    Greenhorn._elmnts.main.appendChild(Greenhorn._elmnts.title);

    Greenhorn._elmnts.main.appendChild(Greenhorn._elmnts.leftPanel);

    Greenhorn._elmnts.main.appendChild(Greenhorn._elmnts.canvas);

    Greenhorn._elmnts.main.appendChild(Greenhorn._elmnts.rightPanel);

    Greenhorn._elmnts.main.appendChild(Greenhorn._elmnts.bottomPanel);

    Greenhorn.getMouseX = function() {
      return document.mouseX - this.get("main", "offsetLeft") - this.get("canvas", "offsetLeft") - this.get("canvas", "width") / 2;
    };

    Greenhorn.getMouseY = function() {
      return document.mouseY - this.get("main", "offsetTop") - this.get("canvas", "offsetTop") - this.get("canvas", "height") / 2;
    };

    Greenhorn.get = function(elmnt, attr) {
      if (attr) {
        return this._elmnts[elmnt][attr];
      } else {
        return this._elmnts[elmnt];
      }
    };

    Greenhorn.set = function(elmnt, attr, what) {
      var value, _results;
      if (Object.prototype.toString.call(what) === '[object Object]') {
        _results = [];
        for (key in what) {
          if (!__hasProp.call(what, key)) continue;
          value = what[key];
          _results.push(this._elmnts[elmnt][attr][key] = value);
        }
        return _results;
      } else {
        return this._elmnts[elmnt][attr] = what;
      }
    };

    Greenhorn.addButton = function(where, label, style, whenClicked) {
      var button, value;
      if (label == null) {
        label = env.BUTTON_DEFAULT_LABEL;
      }
      if (style == null) {
        style = {};
      }
      if (whenClicked == null) {
        whenClicked = (function(_this) {
          return function() {};
        })(this);
      }
      button = document.createElement("button");
      button.setAttribute("type", "button");
      button.innerHTML = label;
      for (key in style) {
        value = style[key];
        button.style[key] = value;
      }
      button.onclick = whenClicked;
      return this._elmnts[where].appendChild(button);
    };

    Greenhorn.start = function() {
      var bottomPanelStyle, canvasStyle, correctHeight, correctWidth, leftPanelStyle, mainStyle, rightPanelStyle, titleStyle;
      document.body.bgColor = env.BODY_BACKGROUND_COLOR;
      document.body.appendChild(this._elmnts.main);
      mainStyle = {
        width: "100%",
        display: "inline-block",
        backgroundColor: env.ENGINE_BACKGROUND_COLOR
      };
      titleStyle = {
        textAlign: "center",
        cssFloat: "left",
        display: "initial",
        marginTop: "1%",
        marginBottom: "1%",
        backgroundColor: "inherit",
        minWidth: "100%",
        minHeight: "6%",
        maxWidth: "100%",
        maxHeight: "6%"
      };
      leftPanelStyle = {
        minWidth: "15%",
        minHeight: "80%",
        maxWidth: "15%",
        maxHeight: "80%",
        cssFloat: "left",
        display: "initial",
        marginLeft: "1%",
        marginRight: "1%",
        overflow: "auto",
        whiteSpace: "pre",
        backgroundColor: "inherit"
      };
      canvasStyle = {
        minWidth: "66%",
        minHeight: "80%",
        maxWidth: "66%",
        maxHeight: "80%",
        display: "initial",
        cssFloat: "left",
        backgroundColor: env.ENGINE_CANVAS_COLOR
      };
      rightPanelStyle = {
        minWidth: "15%",
        minHeight: "80%",
        maxWidth: "15%",
        maxHeight: "80%",
        display: "initial",
        cssFloat: "left",
        marginLeft: "1%",
        marginRight: "1%",
        overflow: "auto",
        whiteSpace: "pre",
        backgroundColor: "inherit"
      };
      bottomPanelStyle = {
        minWidth: "100%",
        minHeight: "10%",
        maxWidth: "100%",
        maxHeight: "10%",
        display: "initial",
        textAlign: "center",
        cssFloat: "left",
        marginTop: "1%",
        marginBottom: "1%",
        backgroundColor: "inherit"
      };
      this.set("main", "style", mainStyle);
      this.set("title", "style", titleStyle);
      this.set("leftPanel", "style", leftPanelStyle);
      this.set("canvas", "style", canvasStyle);
      this.set("rightPanel", "style", rightPanelStyle);
      this.set("bottomPanel", "style", bottomPanelStyle);
      correctWidth = this.get("canvas", "offsetWidth");
      correctHeight = this.get("canvas", "offsetHeight");
      this.set("canvas", "width", correctWidth);
      this.set("canvas", "height", correctHeight);
      this._elmnts.canvas.getContext("2d").translate(this.get("canvas", "width") / 2, this.get("canvas", "height") / 2);
      this.set("title", "innerHTML", document.title);
      this.set("leftPanel", "innerHTML", env.ENGINE_LEFT_PANEL);
      this.set("rightPanel", "innerHTML", env.ENGINE_RIGHT_PANEL);
      this.set("bottomPanel", "innerHTML", env.ENGINE_BOTTOM_PANEL);
      this.set("canvas", "innerHTML", "your browser does not support the <canvas> tag");
      _masterID = setInterval(_masterUpdate, Math.ceil(1000 / env.FRAME_RATE));
    };

    Greenhorn.stop = function() {
      return clearInterval(_masterID);
    };

    Greenhorn.clear = function() {
      return this._elmnts.canvas.getContext("2d").clearRect(-this.get("canvas", "width") / 2, -this.get("canvas", "height") / 2, this.get("canvas", "width"), this.get("canvas", "height"));
    };

    Greenhorn.hide = function() {
      return set("main", "style", {
        "display": "none"
      });
    };

    Greenhorn.show = function() {
      return set("main", "style", {
        "display": "inline-block"
      });
    };

    Greenhorn.hideCursor = function() {
      return set("canvas", "style", {
        "cursor": "none"
      });
    };

    Greenhorn.showCursor = function() {
      return set("canvas", "style", {
        "cursor": "default"
      });
    };

    return Greenhorn;

  })();


  /*
  sprite.coffee
  
  The Greenhorn Gaming Engine core class
   */

  makeSortRule = function(sortBy, order) {
    if (order === "ascending") {
      return function(sp1, sp2) {
        return sp1.get(sortBy) - sp2.get(sortBy);
      };
    } else if (order === "decending") {
      return function(sp1, sp2) {
        return sp2.get(sortBy) - sp1.get(sortBy);
      };
    } else {
      throw new Error("order must be ascending or decending");
    }
  };

  this.Sprite = (function() {
    var _list, _sortRule;

    _list = [];

    _sortRule = makeSortRule("z", "ascending");

    Sprite.howMany = function() {
      return _list.length;
    };

    Sprite._drawAll = function() {
      var sp, _i, _len;
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        sp._draw();
      }
    };

    Sprite.getAll = function() {
      var excep, sp, what, _i, _len, _results;
      what = arguments[0], excep = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.get(what));
        }
      }
      return _results;
    };

    Sprite.setAll = function() {
      var excep, sp, to, what, _i, _len, _results;
      what = arguments[0], to = arguments[1], excep = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      _results = [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.set(what, to));
        }
      }
      return _results;
    };

    Sprite.changeAll = function() {
      var excep, sp, step, what, _i, _len, _results;
      what = arguments[0], step = arguments[1], excep = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      _results = [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.change(what, step));
        }
      }
      return _results;
    };

    function Sprite(config) {
      var forbidden, value, _i, _len, _ref;
      if (config == null) {
        config = {};
      }
      this._update = __bind(this._update, this);
      forbidden = ["display", "position", "motion", "acceleration", "config", "distance", "speed", "rate", "posAngle", "motAngle", "accAngle"];
      for (_i = 0, _len = forbidden.length; _i < _len; _i++) {
        key = forbidden[_i];
        if (config[key] != null) {
          throw new Error("" + key + " is a forbidden config value");
        }
      }
      this._dis = {};
      this._pos = {};
      this._mot = {};
      this._acc = {};
      this._dis.context = Greenhorn._elmnts.canvas.getContext("2d");
      _ref = env.SPRITE_DEFAULT_CONFIG;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      this.set("config", config);
      setInterval(this._update, Math.ceil(1000 / env.FRAME_RATE));
      _list.push(this);
      _list.sort(_sortRule);
    }

    Sprite.prototype.get = function(what) {
      switch (what) {
        case "display":
          return this._dis;
        case "position":
          return this._pos;
        case "motion":
          return this._mot;
        case "acceleration":
          return this._acc;
        case "imageFile":
          return this._dis.image.src;
        case "width":
        case "height":
        case "visible":
        case "boundAction":
          return this._dis[what];
        case "x":
        case "y":
        case "z":
        case "a":
          return this._pos[what];
        case "dx":
        case "dy":
        case "dz":
        case "da":
          return this._mot[what];
        case "ddx":
        case "ddy":
        case "ddz":
        case "dda":
          return this._acc[what];
        case "top":
          return this._pos.y + this._dis.height / 2;
        case "bottom":
          return this._pos.y - this._dis.height / 2;
        case "right":
          return this._pos.x + this._dis.width / 2;
        case "left":
          return this._pos.x - this._dis.width / 2;
        case "distance":
          return Math.sqrt(Math.pow(this._pos.x, 2) + Math.pow(this._pos.y, 2));
        case "speed":
          return Math.sqrt(Math.pow(this._mot.dx, 2) + Math.pow(this._mot.dy, 2));
        case "rate":
          return Math.sqrt(Math.pow(this._acc.ddx, 2) + Math.pow(this._acc.ddy, 2));
        case "posAngle":
          return Math.atan2(this._pos.y, this._pos.x);
        case "motAngle":
          return Math.atan2(this._mot.dy, this._mot.dx);
        case "accAngle":
          return Math.atan2(this._acc.ddy, this._acc.ddx);
        default:
          throw new Error("" + what + " is not a get-able Sprite attribute");
      }
    };

    Sprite.prototype.set = function(what, to) {
      var k, proxy, v, _base;
      switch (what) {
        case "display":
        case "position":
        case "motion":
        case "acceleration":
        case "config":
          for (k in to) {
            if (!__hasProp.call(to, k)) continue;
            v = to[k];
            this.set(k, v);
          }
          break;
        case "imageFile":
          if ((_base = this._dis).image == null) {
            _base.image = new Image();
          }
          this._dis.image.src = env.IMAGE_PATH.concat(to);
          break;
        case "width":
        case "height":
        case "visible":
        case "boundAction":
          this._dis[what] = to;
          break;
        case "x":
        case "y":
        case "z":
        case "a":
          this._pos[what] = to;
          if (what === "z") {
            _list.sort(_sortRule);
          }
          break;
        case "dx":
        case "dy":
        case "dz":
        case "da":
          this._mot[what] = to;
          break;
        case "ddx":
        case "ddy":
        case "ddz":
        case "dda":
          this._acc[what] = to;
          break;
        case "distance":
          proxy = {
            x: to * Math.cos(this.get("posAngle")),
            y: to * Math.sin(this.get("posAngle"))
          };
          this.set("position", proxy);
          break;
        case "speed":
          proxy = {
            dx: to * Math.cos(this.get("motAngle")),
            dy: to * Math.sin(this.get("motAngle"))
          };
          this.set("motion", proxy);
          break;
        case "rate":
          proxy = {
            ddx: to * Math.cos(this.get("accAngle")),
            ddy: to * Math.sin(this.get("accAngle"))
          };
          this.set("acceleration", proxy);
          break;
        case "posAngle":
          proxy = {
            x: this.get("distance") * Math.cos(to),
            y: this.get("distance") * Math.sin(to)
          };
          this.set("position", proxy);
          break;
        case "motAngle":
          proxy = {
            dx: this.get("speed") * Math.cos(to),
            dy: this.get("speed") * Math.sin(to)
          };
          this.set("motion", proxy);
          break;
        case "accAngle":
          proxy = {
            ddx: this.get("rate") * Math.cos(to),
            ddy: this.get("rate") * Math.sin(to)
          };
          this.set("acceleration", proxy);
          break;
        default:
          throw new Error("" + what + " is not a set-able Sprite attribute");
      }
      return this;
    };

    Sprite.prototype.change = function(what, step) {
      var k, proxy, v;
      switch (what) {
        case "display":
        case "position":
        case "motion":
        case "acceleration":
          for (k in step) {
            if (!__hasProp.call(step, k)) continue;
            v = step[k];
            this.change(k.slice(1), v);
          }
          break;
        case "width":
        case "height":
          this._dis[what] += step / env.FRAME_RATE;
          break;
        case "x":
        case "y":
        case "z":
        case "a":
          this._pos[what] += step / env.FRAME_RATE;
          if (what === "z") {
            _list.sort(_sortRule);
          }
          break;
        case "dx":
        case "dy":
        case "dz":
        case "da":
          this._mot[what] += step / env.FRAME_RATE;
          break;
        case "ddx":
        case "ddy":
        case "ddz":
        case "dda":
          this._acc[what] += step / env.FRAME_RATE;
          break;
        case "distance":
          proxy = {
            dx: step * Math.cos(this.get("posAngle")),
            dy: step * Math.sin(this.get("posAngle"))
          };
          this.change("position", proxy);
          break;
        case "speed":
          proxy = {
            ddx: step * Math.cos(this.get("motAngle")),
            ddy: step * Math.sin(this.get("motAngle"))
          };
          this.change("motion", proxy);
          break;
        case "rate":
          proxy = {
            dddx: step * Math.cos(this.get("accAngle")),
            dddy: step * Math.sin(this.get("accAngle"))
          };
          this.change("acceleration", proxy);
          break;
        case "posAngle":
          proxy = {
            dx: this.get("distance") * Math.cos(step),
            dy: this.get("distance") * Math.sin(step)
          };
          this.change("position", proxy);
          break;
        case "motAngle":
          proxy = {
            ddx: this.get("speed") * Math.cos(step),
            ddy: this.get("speed") * Math.sin(step)
          };
          this.change("motion", proxy);
          break;
        case "accAngle":
          proxy = {
            dddx: this.get("rate") * Math.cos(step),
            dddy: this.get("rate") * Math.sin(step)
          };
          this.change("acceleration", proxy);
          break;
        default:
          throw new Error("" + what + " is not a change-able Sprite attribute");
      }
      return this;
    };

    Sprite.prototype.collidesWith = function(other) {
      var collision;
      collision = true;
      if (this._dis.visible && other.get("visible") && this._pos.z === other.get("z")) {
        if (this.get("bottom") > other.get("top") || this.get("top") < other.get("bottom") || this.get("right") < other.get("left") || this.get("left") > other.get("right")) {
          collision = false;
        }
      } else {
        collision = false;
      }
      return collision;
    };

    Sprite.prototype.collidesWithMouse = function() {
      var collision, _ref, _ref1;
      collision = false;
      if (this._dis.visible) {
        if ((this.get("left") < (_ref = Greenhorn.getMouseX()) && _ref < this.get("right")) && (this.get("bottom") < (_ref1 = Greenhorn.getMouseY()) && _ref1 < this.get("top"))) {
          collision = true;
        }
      }
      return collision;
    };

    Sprite.prototype.distanceTo = function(other) {
      return Math.sqrt(Math.pow(this._pos.x - other.get("x"), 2) + Math.pow(this._pos.y - other.get("y"), 2));
    };

    Sprite.prototype.distanceToMouse = function() {
      return Math.sqrt(Math.pow(this._pos.x - Greenhorn.getMouseX(), 2) + Math.pow(this._pos.y - Greenhorn.getMouseY(), 2));
    };

    Sprite.prototype.angleTo = function(other) {
      return -Math.atan2(other.get("y") - this._pos.y, other.get("x") - this._pos.x);
    };

    Sprite.prototype.angleToMouse = function() {
      return -Math.atan2(Greenhorn.getMouseY() - this._pos.y, Greenhorn.getMouseX() - this._pos.x);
    };

    Sprite.prototype._draw = function() {
      this._dis.context.save();
      this._dis.context.translate(this._pos.x, -this._pos.y);
      this._dis.context.rotate(-this._pos.a);
      this._dis.context.drawImage(this._dis.image, -this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
      return this._dis.context.restore();
    };

    Sprite.prototype._update = function() {
      var bounds, hitBottom, hitLeft, hitRight, hitTop, offBottom, offLeft, offRight, offTop;
      if (this._dis.visible) {
        this.change("motion", this._acc);
        this.change("position", this._mot);
        bounds = {
          top: Greenhorn.get("canvas", "height") / 2,
          bottom: -Greenhorn.get("canvas", "height") / 2,
          right: Greenhorn.get("canvas", "width") / 2,
          left: -Greenhorn.get("canvas", "width") / 2
        };
        offTop = this.get("bottom") > bounds.top;
        offBottom = this.get("top") < bounds.bottom;
        offRight = this.get("left") > bounds.right;
        offLeft = this.get("right") < bounds.left;
        hitTop = this.get("top") >= bounds.top;
        hitBottom = this.get("bottom") <= bounds.bottom;
        hitRight = this.get("right") >= bounds.right;
        hitLeft = this.get("left") <= bounds.left;
        switch (this._dis.boundAction) {
          case "WRAP":
            if (offTop) {
              this.set("y", bounds.bottom - this._dis.height / 2);
            }
            if (offBottom) {
              this.set("y", bounds.top + this._dis.height / 2);
            }
            if (offRight) {
              this.set("x", bounds.left - this._dis.width / 2);
            }
            if (offLeft) {
              this.set("x", bounds.right + this._dis.width / 2);
            }
            break;
          case "BOUNCE":
            if (hitTop) {
              this.set("y", bounds.top - this._dis.height / 2);
              this._mot.dy *= -1;
            }
            if (hitBottom) {
              this.set("y", bounds.bottom + this._dis.height / 2);
              this._mot.dy *= -1;
            }
            if (hitRight) {
              this.set("x", bounds.right - this._dis.width / 2);
              this._mot.dx *= -1;
            }
            if (hitLeft) {
              this.set("x", bounds.left + this._dis.width / 2);
              this._mot.dx *= -1;
            }
            break;
          case "SEMIBOUNCE":
            if (hitTop) {
              this.set("y", bounds.top - this._dis.height / 2);
              this._mot.dy *= -.75;
            }
            if (hitBottom) {
              this.set("y", bounds.bottom + this._dis.height / 2);
              this._mot.dy *= -.75;
            }
            if (hitRight) {
              this.set("x", bounds.right - this._dis.width / 2);
              this._mot.dx *= -.75;
            }
            if (hitLeft) {
              this.set("x", bounds.left + this._dis.width / 2);
              this._mot.dx *= -.75;
            }
            break;
          case "STOP":
            if (hitTop || hitBottom || hitRight || hitLeft) {
              this._mot.dx = 0;
              this._mot.dy = 0;
              this._acc.ddx = 0;
              this._acc.ddy = 0;
              if (hitTop) {
                this.set("y", bounds.top - this._dis.height / 2);
              }
              if (hitBottom) {
                this.set("y", bounds.bottom + this._dis.height / 2);
              }
              if (hitRight) {
                this.set("x", bounds.right - this._dis.width / 2);
              }
              if (hitLeft) {
                this.set("x", bounds.left + this._dis.width / 2);
              }
            }
            break;
          case "DIE":
            if (offTop || offBottom || offRight || offLeft) {
              this._dis.visible = false;
            }
        }
      }
      return this;
    };

    Sprite.prototype.report = function() {
      return "display:\n    width: " + (Math.round(this._dis.width)) + "\n    height: " + (Math.round(this._dis.height)) + "\n    visible: " + this._dis.visible + "\n    boundAction: " + this._dis.boundAction + "\nposition:\n    x: " + (this._pos.x.toFixed(3)) + "\n    y: " + (this._pos.y.toFixed(3)) + "\n    z: " + (this._pos.z.toFixed(3)) + "\n    a: " + (this._pos.a.toFixed(3)) + "\nmotion:\n    dx: " + (this._mot.dx.toFixed(3)) + "\n    dy: " + (this._mot.dy.toFixed(3)) + "\n    dz: " + (this._mot.dz.toFixed(3)) + "\n    da: " + (this._mot.da.toFixed(3)) + "\nacceleration:\n    ddx: " + (this._acc.ddx.toFixed(3)) + "\n    ddy: " + (this._acc.ddy.toFixed(3)) + "\n    ddz: " + (this._acc.ddz.toFixed(3)) + "\n    dda: " + (this._acc.dda.toFixed(3));
    };

    Sprite.prototype.log = function() {
      if (typeof console !== "undefined" && console !== null) {
        console.log(this.report());
      }
    };

    return Sprite;

  })();

  this.Sprites = this.Sprite;


  /*
  textBox.coffee
  
  The Greenhorn Gaming TextBox class
   */

  this.TextBox = (function(_super) {
    __extends(TextBox, _super);

    function TextBox(config) {
      var value, _ref;
      if (config == null) {
        config = {};
      }
      _ref = env.TEXTBOX_DEFAULT_CONFIG;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      this._text = [];
      this._background = {};
      this._border = {};
      this._font = {};
      this._margins = {};
      TextBox.__super__.constructor.call(this, config);
    }

    TextBox.prototype.get = function(what) {
      switch (what) {
        case "text":
          return this._text.join('\n');
        case "align":
          return this._dis.context.textAlign;
        case "background":
        case "border":
        case "font":
        case "margins":
          return this["_".concat(what)];
        case what.indexOf("background") === 0:
          return this._background[what.slice(10).toLowerCase()];
        case what.indexOf("border") === 0:
          return this._border[what.slice(6).toLowerCase()];
        case what.indexOf("font") === 0:
          return this._font[what.slice(4).toLowerCase()];
        case what.indexOf("margins") === 0:
          return this._margins[what.slice(7).toLowerCase()];
        default:
          return TextBox.__super__.get.call(this, what);
      }
    };

    TextBox.prototype.set = function(what, to) {
      var k, v;
      if (what === "text") {
        this._text = to.split("\n");
      } else if (what === "align") {
        this._dis.context.textAlign = to;
      } else if (what === "background" || what === "border" || what === "font" || what === "margins") {
        for (k in to) {
          v = to[k];
          this["_".concat(what)][k] = v;
        }
      } else if (what.indexOf("background") === 0) {
        this._background[what.slice(10).toLowerCase()] = to;
      } else if (what.indexOf("border") === 0) {
        this._border[what.slice(6).toLowerCase()] = to;
      } else if (what.indexOf("font") === 0) {
        this._font[what.slice(4).toLowerCase()] = to;
      } else if (what.indexOf("margins") === 0) {
        this._margins[what.slice(7).toLowerCase()] = to;
      } else {
        TextBox.__super__.set.call(this, what, to);
      }
      if ((this._dis.width != null) && (this._dis.height != null) && (this._font.size != null) && (this._margins.left != null) && (this._margins.right != null) && (this._margins.bottom != null) && (this._margins.top != null) && (this._border.visible != null) && (this._border.size != null)) {
        this._fitText();
      }
      return this;
    };

    TextBox.prototype.showBackground = function() {
      this._background.visible = true;
    };

    TextBox.prototype.hideBackground = function() {
      this._background.visible = false;
    };

    TextBox.prototype.showBorder = function() {
      this._border.visible = true;
      this._fitText();
    };

    TextBox.prototype.hideBorder = function() {
      this._border.visible = false;
      this._fitText();
    };

    TextBox.prototype._fitText = function() {
      var len, line, _i, _len, _ref;
      this._dis.width = 0;
      this._dis.height = (this._font.size * this._text.length) + (this._font.size * (this._text.length - 1));
      _ref = this._text;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        len = this._dis.context.measureText(line).width;
        if (this._dis.width < len) {
          this._dis.width = len;
        }
      }
      this._dis.width += this._margins.left + this._margins.right;
      this._dis.height += this._margins.top + this._margins.bottom;
      if (this._border.visible) {
        this._dis.width += 2 * this._border.size;
        this._dis.height += 2 * this._border.size;
      }
      return this;
    };

    TextBox.prototype._draw = function() {
      var i, line, xOffset, yOffset, _i, _len, _ref;
      this._dis.context.save();
      this._dis.context.translate(this._pos.x, -this._pos.y);
      this._dis.context.rotate(-this._pos.a);
      if (this._background.visible) {
        this._dis.context.fillStyle = this._background.color;
        this._dis.context.globalAlpha = this._background.alpha;
        this._dis.context.fillRect(-this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
      }
      if (this._border.visible) {
        this._dis.context.strokeStyle = this._border.color;
        this._dis.context.lineWidth = this._border.size;
        this._dis.context.globalAlpha = this._border.alpha;
        this._dis.context.strokeRect(-this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
      }
      xOffset = this._margins.left;
      yOffset = this._margins.top + this._font.size;
      if (this._border.visible) {
        xOffset += this._border.size;
        yOffset += this._border.size;
      }
      this._dis.context._font = "" + this._font.size + "px " + this._font.name;
      this._dis.context.fillStyle = this._font.color;
      this._dis.context.globalAlpha = this._font.alpha;
      if (this._text.length > 1) {
        _ref = this._text;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          line = _ref[i];
          this._dis.context.fillText(line, xOffset - (this._dis.width / 2), yOffset - (this._dis.height / 2) + (this._font.size * 2 * i));
        }
      } else {
        this._dis.context.fillText(this._text[0], xOffset - (this._dis.width / 2), yOffset - (this._dis.height / 2));
      }
      this._dis.context.restore();
    };

    return TextBox;

  })(this.Sprite);


  /*
  timer.coffee
  
  The Greenhorn Gaming Timer class
   */

  this.Timer = (function() {
    function Timer(start_now) {
      if (start_now == null) {
        start_now = env.TIMER_START_ON_CONSTRUCTION;
      }
      this._elapsedTime = 0;
      this._startTime = start_now ? this.getCurrentTime() : null;
      return this;
    }

    Timer.prototype.getStartTime = function() {
      return this._startTime;
    };

    Timer.prototype.getCurrentTime = function() {
      return (new Date()).getTime();
    };

    Timer.prototype.getElapsedTime = function() {
      if (!this._startTime) {
        return this._elapsedTime;
      } else {
        return this._elapsedTime + this.getCurrentTime() - this._startTime;
      }
    };

    Timer.prototype.start = function() {
      if (!this._startTime) {
        this._startTime = this.getCurrentTime();
      }
    };

    Timer.prototype.pause = function() {
      if (this._startTime) {
        this._elapsedTime += this.getCurrentTime() - this.getStartTime();
        this._startTime = null;
      }
    };

    Timer.prototype.restart = function() {
      this._elapsedTime = 0;
      this._startTime = this.getCurrentTime();
    };

    Timer.prototype.stop = function() {
      this._elapsedTime = 0;
      this._startTime = null;
    };

    return Timer;

  })();


  /*
  aniSprite.coffee
  
  The Greenhorn Gaming Engine animated Sprite class
   */

  AniCycle = (function() {
    function AniCycle(data) {
      this.frame = 1;
      this.name = data.name;
      this.row = data.row;
      this.numFrames = data.numFrames;
    }

    return AniCycle;

  })();

  this.AniSprite = (function(_super) {
    __extends(AniSprite, _super);

    function AniSprite(config) {
      var value, _ref;
      if (config == null) {
        config = {};
      }
      this._update = __bind(this._update, this);
      _ref = env.ANISPRITE_DEFAULT_CONFIG;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        if (key !== "numFrames") {
          if (config[key] == null) {
            config[key] = value;
          }
        }
      }
      AniSprite.__super__.constructor.call(this, config);
    }

    AniSprite.prototype.get = function(what) {
      switch (what) {
        case "sheetWidth":
        case "sheetHeight":
        case "cellWidth":
        case "cellHeight":
        case "frameRate":
          return this._dis[what];
        case "current":
          return this._dis.current.name;
        default:
          return AniSprite.__super__.get.call(this, what);
      }
    };

    AniSprite.prototype.set = function(what, to) {
      var cycle, i, _base, _base1, _base2, _i, _len, _ref;
      if (what === "sheetWidth" || what === "sheetHeight" || what === "cellWidth" || what === "cellHeight" || what === "frameRate") {
        this._dis[what] = to;
      } else if (what === "current") {
        this._dis.current.frame = 1;
        _ref = this._dis.cycles;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cycle = _ref[_i];
          if (cycle.name === to) {
            this._dis.current = cycle;
          }
        }
      } else if (what.indexOf("cycle") === 0) {
        if ((_base = this._dis).cycles == null) {
          _base.cycles = new Array();
        }
        if ((_base1 = this._dis).timer == null) {
          _base1.timer = new Timer();
        }
        i = 0;
        if (to.name == null) {
          to.name = what.slice(5);
        }
        if (to.row == null) {
          to.row = i += 1;
        }
        if (to.numFrames == null) {
          to.numFrames = env.ANISPRITE_DEFAULT_CONFIG.numFrames;
        }
        this._dis.cycles.push(new AniCycle(to));
        if ((_base2 = this._dis).current == null) {
          _base2.current = to;
        }
      } else {
        AniSprite.__super__.set.call(this, what, to);
      }
      return this;
    };

    AniSprite.prototype.play = function() {
      this._dis.timer.start();
      return this;
    };

    AniSprite.prototype.pause = function() {
      this._dis.timer.pause();
      return this;
    };

    AniSprite.prototype._draw = function() {
      this._dis.context.save();
      this._dis.context.translate(this._pos.x, -this._pos.y);
      this._dis.context.rotate(-this._pos.a);
      this._dis.context.drawImage(this._dis.image, (this._dis.current.frame - 1) * this._dis.cellWidth, (this._dis.current.row - 1) * this._dis.cellHeight, this._dis.cellWidth, this._dis.cellHeight, -this._dis.width / 2, -this._dis.height / 2, this._dis.width, this._dis.height);
      return this._dis.context.restore();
    };

    AniSprite.prototype._update = function() {
      if (this._dis.timer.getElapsedTime() >= (1000 / this._dis.frameRate)) {
        if (this._dis.current.frame < this._dis.current.numFrames) {
          this._dis.current.frame += 1;
        } else {
          this._dis.current.frame = 1;
        }
        this._dis.timer.restart();
      }
      return AniSprite.__super__._update.call(this);
    };

    return AniSprite;

  })(this.Sprite);


  /*
  sound.coffee
  
  Greenhorn Gaming Engine Sound class
   */

  if ((this.AudioContext != null) || (this.webkitAudioContext != null)) {
    AudioContext = (_ref = this.AudioContext) != null ? _ref : this.webkitAudioContext;
    _audioContext = new AudioContext();
  } else {
    env.USE_AUDIO_TAG = true;
  }

  this.Sound = (function() {
    function Sound(config) {
      var mp3_src, ogg_src, request, value, wav_src, _ref1;
      if (config == null) {
        config = {};
      }
      _ref1 = env.SOUND_DEFAULT_CONFIG;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        value = _ref1[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      config.url = env.SOUND_PATH.concat(config.url);
      if (env.USE_AUDIO_TAG) {
        this._audio = document.createElement('audio');
        mp3_src = document.createElement('source');
        ogg_src = document.createElement('source');
        wav_src = document.createElement('source');
        mp3_src.type = 'audio/mpeg';
        ogg_src.type = 'audio/ogg';
        wav_src.type = 'audio/wav';
        if (config.url.indexOf('.mp3') !== -1) {
          mp3_src.src = config.url;
          ogg_src.src = config.url.replace('.mp3', '.ogg');
          wav_src.src = config.url.replace('.mp3', '.wav');
        } else if (config.url.indexOf('.ogg') !== -1) {
          ogg_src.src = config.url;
          mp3_src.src = config.url.replace('.ogg', '.mp3');
          wav_src.src = config.url.replace('.ogg', '.wav');
        } else if (config.url.indexOf('.wav') !== -1) {
          wav_src.src = config.url;
          mp3_src.src = config.url.replace('.wav', '.mp3');
          ogg_src.src = config.url.replace('.wav', '.ogg');
        } else {
          throw new Error("Only .mp3, .ogg, and .wav file extensions are supported by the audio tag");
        }
        this._audio.appendChild(mp3_src);
        this._audio.appendChild(ogg_src);
        this._audio.appendChild(wav_src);
        if (config.playOnLoad) {
          this._audio.autoplay = true;
        }
      } else {
        this._buffer = null;
        this._source = null;
        this._isEnded = true;
        request = new XMLHttpRequest();
        request.open('GET', config.url, true);
        request.responseType = 'arraybuffer';
        request.successCallback = (function(_this) {
          return function(buffer) {
            _this._buffer = buffer;
            if (config.playOnLoad) {
              return _this.play();
            }
          };
        })(this);
        request.errorCallback = function() {
          throw new Error("Web Audio API Error");
        };
        request.onload = function() {
          return _audioContext.decodeAudioData(this.response, this.successCallback, this.errorCallback);
        };
        request.send();
      }
    }

    Sound.prototype.play = function(opt) {
      var gainNode, _ref1, _ref2, _ref3, _ref4;
      if (opt == null) {
        opt = {};
      }
      if (env.USE_AUDIO_TAG) {
        this._audio.loop = (_ref1 = opt.loop) != null ? _ref1 : false;
        this._audio.volume = (_ref2 = opt.volume) != null ? _ref2 : 1.0;
        return this._audio.play();
      } else {
        if (this._isEnded) {
          gainNode = _audioContext.createGain();
          gainNode.gain.value = (_ref3 = opt.volume) != null ? _ref3 : 1.0;
          this._isEnded = false;
          this._source = _audioContext.createBufferSource();
          this._source.buffer = this._buffer;
          this._source.onended = (function(_this) {
            return function() {
              return _this._isEnded = true;
            };
          })(this);
          this._source.loop = (_ref4 = opt.loop) != null ? _ref4 : false;
          this._source.connect(gainNode);
          gainNode.connect(_audioContext.destination);
          return this._source.start();
        }
      }
    };

    Sound.prototype.stop = function() {
      if (env.USE_AUDIO_TAG) {
        this._audio.pause();
        return this._audio.currentTime = 0;
      } else {
        return this._source.stop();
      }
    };

    return Sound;

  })();

}).call(this);
