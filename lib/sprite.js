// Generated by CoffeeScript 1.8.0

/*
sprite.coffee

The Greenhorn Gaming Engine core class
 */

(function() {
  var BOUND_ACTIONS, Greenhorn, env, game, makeSortRule,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  game = typeof exports !== "undefined" && exports !== null ? exports : this;

  env = require('./environment').env;

  Greenhorn = require('./greenhorn').Greenhorn;

  BOUND_ACTIONS = {
    WRAP: 0,
    BOUNCE: 1,
    SEMIBOUNCE: 2,
    STOP: 3,
    DIE: 4,
    CONTINUE: 5
  };

  makeSortRule = function(sortBy, order) {
    if (order === "ascending") {
      return function(sp1, sp2) {
        return sp1.get(sortBy) - sp2.get(sortBy);
      };
    } else if (order === "decending") {
      return function(sp1, sp2) {
        return sp2.get(sortBy) - sp1.get(sortBy);
      };
    } else {
      throw new Error("order must be ascending or decending");
    }
  };

  game.Sprite = (function() {
    var _list, _sortRule;

    _list = [];

    _sortRule = makeSortRule("z", "ascending");

    Sprite.howMany = function() {
      return _list.length;
    };

    Sprite._updateAll = function() {
      var sp, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        _results.push(sp._update());
      }
      return _results;
    };

    Sprite.getAll = function() {
      var excep, sp, what, _i, _len, _results;
      what = arguments[0], excep = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.get(what));
        }
      }
      return _results;
    };

    Sprite.setAll = function() {
      var excep, sp, to, what, _i, _len, _results;
      what = arguments[0], to = arguments[1], excep = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      _results = [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.set(what, to));
        }
      }
      return _results;
    };

    Sprite.changeAll = function() {
      var excep, sp, step, what, _i, _len, _results;
      what = arguments[0], step = arguments[1], excep = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      _results = [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.change(what, step));
        }
      }
      return _results;
    };

    function Sprite(config) {
      var forbidden, key, value, _i, _len, _ref;
      if (config == null) {
        config = {};
      }
      forbidden = ["display", "position", "motion", "acceleration", "config", "distance", "speed", "rate", "posAngle", "motAngle", "accAngle"];
      for (_i = 0, _len = forbidden.length; _i < _len; _i++) {
        key = forbidden[_i];
        if (config[key] != null) {
          throw new Error("" + key + " is a forbidden config value");
        }
      }
      this._dis = {};
      this._pos = {};
      this._mot = {};
      this._acc = {};
      this._borders = {};
      this._dis.context = Greenhorn._elmnts.canvas.getContext("2d");
      _ref = env.SPRITE_DEFAULT_CONFIG;
      for (key in _ref) {
        value = _ref[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      _list.push(this);
      this.set("config", config);
    }

    Sprite.prototype.get = function(what) {
      switch (what) {
        case "display":
          return this._dis;
        case "position":
          return this._pos;
        case "motion":
          return this._mot;
        case "acceleration":
          return this._acc;
        case "borders":
          return this._borders;
        case "imageFile":
          return this._dis.image.src;
        case "width":
        case "height":
        case "visible":
        case "boundAction":
          return this._dis[what];
        case "x":
        case "y":
        case "z":
        case "a":
          return this._pos[what];
        case "dx":
        case "dy":
        case "dz":
        case "da":
          return this._mot[what];
        case "ddx":
        case "ddy":
        case "ddz":
        case "dda":
          return this._acc[what];
        case "top":
        case "bottom":
        case "right":
        case "left":
          return this._borders[what];
        case "distance":
          return Math.sqrt(Math.pow(this._pos.x, 2) + Math.pow(this._pos.y, 2));
        case "speed":
          return Math.sqrt(Math.pow(this._mot.dx, 2) + Math.pow(this._mot.dy, 2));
        case "rate":
          return Math.sqrt(Math.pow(this._acc.ddx, 2) + Math.pow(this._acc.ddy, 2));
        case "posAngle":
          return Math.atan2(this._pos.y, this._pos.x);
        case "motAngle":
          return Math.atan2(this._mot.dy, this._mot.dx);
        case "accAngle":
          return Math.atan2(this._acc.ddy, this._acc.ddx);
        default:
          throw new Error("" + what + " is not a get-able Sprite attribute");
      }
    };

    Sprite.prototype.set = function(what, to) {
      var k, proxy, v, _base;
      switch (what) {
        case "display":
        case "position":
        case "motion":
        case "acceleration":
        case "config":
          for (k in to) {
            v = to[k];
            this.set(k, v);
          }
          break;
        case "imageFile":
          if ((_base = this._dis).image == null) {
            _base.image = new Image();
          }
          this._dis.image.src = env.IMAGE_PATH.concat(to);
          break;
        case "boundAction":
          this._dis.boundAction = BOUND_ACTIONS[to];
          break;
        case "width":
        case "height":
        case "visible":
          this._dis[what] = to;
          if (what === "width" || what === "height") {
            this._calcBorders();
          }
          break;
        case "x":
        case "y":
        case "z":
        case "a":
          this._pos[what] = to;
          if (what === "x" || what === "y") {
            this._calcBorders();
          }
          if (what === "z") {
            _list.sort(_sortRule);
          }
          break;
        case "dx":
        case "dy":
        case "dz":
        case "da":
          this._mot[what] = to;
          break;
        case "ddx":
        case "ddy":
        case "ddz":
        case "dda":
          this._acc[what] = to;
          break;
        case "distance":
          proxy = {
            x: to * Math.cos(this.get("posAngle")),
            y: to * Math.sin(this.get("posAngle"))
          };
          this.set("position", proxy);
          break;
        case "speed":
          proxy = {
            dx: to * Math.cos(this.get("motAngle")),
            dy: to * Math.sin(this.get("motAngle"))
          };
          this.set("motion", proxy);
          break;
        case "rate":
          proxy = {
            ddx: to * Math.cos(this.get("accAngle")),
            ddy: to * Math.sin(this.get("accAngle"))
          };
          this.set("acceleration", proxy);
          break;
        case "posAngle":
          proxy = {
            x: this.get("distance") * Math.cos(to),
            y: this.get("distance") * Math.sin(to)
          };
          this.set("position", proxy);
          break;
        case "motAngle":
          proxy = {
            dx: this.get("speed") * Math.cos(to),
            dy: this.get("speed") * Math.sin(to)
          };
          this.set("motion", proxy);
          break;
        case "accAngle":
          proxy = {
            ddx: this.get("rate") * Math.cos(to),
            ddy: this.get("rate") * Math.sin(to)
          };
          this.set("acceleration", proxy);
          break;
        default:
          throw new Error("" + what + " is not a set-able Sprite attribute");
      }
      return this;
    };

    Sprite.prototype.change = function(what, step) {
      var k, proxy, v;
      switch (what) {
        case "display":
        case "position":
        case "motion":
        case "acceleration":
          for (k in step) {
            v = step[k];
            this.change(k.slice(1), v);
          }
          break;
        case "width":
        case "height":
          this._dis[what] += step;
          this._calcBorders();
          break;
        case "x":
        case "y":
        case "z":
        case "a":
          this._pos[what] += step / env.FRAME_RATE;
          if (what === "x" || what === "y") {
            this._calcBorders();
          }
          if (what === "z") {
            _list.sort(_sortRule);
          }
          break;
        case "dx":
        case "dy":
        case "dz":
        case "da":
          this._mot[what] += step / env.FRAME_RATE;
          break;
        case "ddx":
        case "ddy":
        case "ddz":
        case "dda":
          this._acc[what] += step / env.FRAME_RATE;
          break;
        case "distance":
          proxy = {
            dx: step * Math.cos(this.get("posAngle")),
            dy: step * Math.sin(this.get("posAngle"))
          };
          this.change("position", proxy);
          break;
        case "speed":
          proxy = {
            ddx: step * Math.cos(this.get("motAngle")),
            ddy: step * Math.sin(this.get("motAngle"))
          };
          this.change("motion", proxy);
          break;
        case "rate":
          proxy = {
            dddx: step * Math.cos(this.get("accAngle")),
            dddy: step * Math.sin(this.get("accAngle"))
          };
          this.change("acceleration", proxy);
          break;
        case "posAngle":
          proxy = {
            dx: this.get("distance") * Math.cos(step),
            dy: this.get("distance") * Math.sin(step)
          };
          this.change("position", proxy);
          break;
        case "motAngle":
          proxy = {
            ddx: this.get("speed") * Math.cos(step),
            ddy: this.get("speed") * Math.sin(step)
          };
          this.change("motion", proxy);
          break;
        case "accAngle":
          proxy = {
            dddx: this.get("rate") * Math.cos(step),
            dddy: this.get("rate") * Math.sin(step)
          };
          this.change("acceleration", proxy);
          break;
        default:
          throw new Error("" + what + " is not a change-able Sprite attribute");
      }
      return this;
    };

    Sprite.prototype.collidesWith = function(other) {
      var collision;
      collision = true;
      if (this._dis.visible && other._dis.visible && this._pos.z === other.get("z")) {
        if (this._borders.bottom > other._borders.top || this._borders.top < other._borders.bottom || this._borders.right < other._borders.left || this._borders.left > other._borders.right) {
          collision = false;
        }
      } else {
        collision = false;
      }
      return collision;
    };

    Sprite.prototype.collidesWithMouse = function() {
      var collision, _ref, _ref1;
      collision = false;
      if (this._dis.visible) {
        if ((this._borders.left < (_ref = Greenhorn.getMouseX()) && _ref < this._borders.right) && (this._borders.bottom < (_ref1 = Greenhorn.getMouseY()) && _ref1 < this._borders.top)) {
          collision = true;
        }
      }
      return collision;
    };

    Sprite.prototype.distanceTo = function(other) {
      return Math.sqrt(Math.pow(this._pos.x - other.get("x"), 2) + Math.pow(this._pos.y - other.get("y"), 2));
    };

    Sprite.prototype.distanceToMouse = function() {
      return Math.sqrt(Math.pow(this._pos.x - Greenhorn.getMouseX(), 2) + Math.pow(this._pos.y - Greenhorn.getMouseY(), 2));
    };

    Sprite.prototype.angleTo = function(other) {
      return -Math.atan2(other.get("y") - this._pos.y, other.get("x") - this._pos.x);
    };

    Sprite.prototype.angleToMouse = function() {
      return -Math.atan2(Greenhorn.getMouseY() - this._pos.y, Greenhorn.getMouseX() - this._pos.x);
    };

    Sprite.prototype._calcBorders = function() {
      this._borders.left = this._pos.x - this._dis.width / 2;
      this._borders.right = this._pos.x + this._dis.width / 2;
      this._borders.top = this._pos.y + this._dis.height / 2;
      return this._borders.bottom = this._pos.y - this._dis.height / 2;
    };

    Sprite.prototype._draw = function() {
      this._dis.context.save();
      this._dis.context.translate(this._pos.x, -this._pos.y);
      this._dis.context.rotate(this._pos.a);
      this._dis.context.drawImage(this._dis.image, 0 - this._dis.width / 2, 0 - this._dis.height / 2, this._dis.width, this._dis.height);
      return this._dis.context.restore();
    };

    Sprite.prototype._checkBounds = function() {
      var bounds, hitBottom, hitLeft, hitRight, hitTop, offBottom, offLeft, offRight, offTop;
      bounds = {
        top: Greenhorn.get("canvas", "height") / 2,
        left: -Greenhorn.get("canvas", "width") / 2,
        bottom: -Greenhorn.get("canvas", "height") / 2,
        right: Greenhorn.get("canvas", "width") / 2
      };
      offLeft = this._borders.right < bounds.left;
      offTop = this._borders.bottom > bounds.top;
      offRight = this._borders.left > bounds.right;
      offBottom = this._borders.top < bounds.bottom;
      hitLeft = this._borders.left <= bounds.left;
      hitTop = this._borders.top >= bounds.top;
      hitRight = this._borders.right >= bounds.right;
      hitBottom = this._borders.bottom <= bounds.bottom;
      switch (this._dis.boundAction) {
        case BOUND_ACTIONS.WRAP:
          if (offLeft) {
            this.set("x", bounds.right + this._dis.width / 2);
          }
          if (offTop) {
            this.set("y", bounds.bottom - this._dis.height / 2);
          }
          if (offRight) {
            this.set("x", bounds.left - this._dis.width / 2);
          }
          if (offBottom) {
            this.set("y", bounds.top + this._dis.height / 2);
          }
          break;
        case BOUND_ACTIONS.BOUNCE:
          if (hitTop) {
            this.set("y", bounds.top - this._dis.height / 2);
            this._mot.dy *= -1;
          }
          if (hitBottom) {
            this.set("y", bounds.bottom + this._dis.height / 2);
            this._mot.dy *= -1;
          }
          if (hitLeft) {
            this.set("x", bounds.left + this._dis.width / 2);
            this._mot.dx *= -1;
          }
          if (hitRight) {
            this.set("x", bounds.right - this._dis.width / 2);
            this._mot.dx *= -1;
          }
          break;
        case BOUND_ACTIONS.SEMIBOUNCE:
          if (hitTop) {
            this.set("y", bounds.top - this._dis.height / 2);
            this._mot.dy *= -.75;
          }
          if (hitBottom) {
            this.set("y", bounds.bottom + this._dis.height / 2);
            this._mot.dy *= -.75;
          }
          if (hitLeft) {
            this.set("x", bounds.left + this._dis.width / 2);
            this._mot.dx *= -.75;
          }
          if (hitRight) {
            this.set("x", bounds.right - this._dis.width / 2);
            this._mot.dx *= -.75;
          }
          break;
        case BOUND_ACTIONS.STOP:
          if (hitLeft || hitTop || hitRight || hitBottom) {
            this._mot.dx = 0;
            this._mot.dy = 0;
            this._acc.ddx = 0;
            this._acc.ddy = 0;
            if (hitTop) {
              this.set("y", bounds.top - this._dis.height / 2);
            }
            if (hitBottom) {
              this.set("y", bounds.bottom + this._dis.height / 2);
            }
            if (hitLeft) {
              this.set("x", bounds.left + this._dis.width / 2);
            }
            if (hitRight) {
              this.set("x", bounds.right - this._dis.width / 2);
            }
          }
          break;
        case BOUND_ACTIONS.DIE:
          if (offLeft || offTop || offRight || offBottom) {
            this._dis.visible = false;
          }
      }
      return this._dis.boundAction;
    };

    Sprite.prototype._update = function() {
      if (this._dis.visible) {
        this.change("motion", this._acc);
        this.change("position", this._mot);
        this._checkBounds();
        this._draw();
      }
      return this;
    };

    Sprite.prototype.report = function() {
      return "display:\n    width: " + (Math.round(this._dis.width)) + "\n    height: " + (Math.round(this._dis.height)) + "\n    visible: " + this._dis.visible + "\n    boundAction: " + this._dis.boundAction + "\nposition:\n    x: " + (this._pos.x.toFixed(3)) + "\n    y: " + (this._pos.y.toFixed(3)) + "\n    z: " + (this._pos.z.toFixed(3)) + "\n    a: " + (this._pos.a.toFixed(3)) + "\nmotion:\n    dx: " + (this._mot.dx.toFixed(3)) + "\n    dy: " + (this._mot.dy.toFixed(3)) + "\n    dz: " + (this._mot.dz.toFixed(3)) + "\n    da: " + (this._mot.da.toFixed(3)) + "\nacceleration:\n    ddx: " + (this._acc.ddx.toFixed(3)) + "\n    ddy: " + (this._acc.ddy.toFixed(3)) + "\n    ddz: " + (this._acc.ddz.toFixed(3)) + "\n    dda: " + (this._acc.dda.toFixed(3));
    };

    Sprite.prototype.log = function() {
      if (typeof console !== "undefined" && console !== null) {
        console.log(this.report());
      }
    };

    return Sprite;

  })();

  game.Sprites = game.Sprite;

}).call(this);
