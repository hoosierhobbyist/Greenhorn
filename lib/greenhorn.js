// Generated by CoffeeScript 1.8.0

/*
greenhorn.coffee
by Seth Bullock

***THE GREENHORN GAMING ENGINE***

primarily inspired by Andy Harris'
(aharrisbooks.net) simpleGame.js gaming engine
 */

(function() {
  var game, key, makeSortRule, _GameError, _masterID, _masterUpdate, _webkitAudioContext,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  game = this;

  game.env = {
    FRAME_RATE: 25,
    BODY_BACKGROUND_COLOR: "goldenrod",
    ENGINE_TITLE: document.title,
    ENGINE_LEFT_PANEL: "LEFT PANEL",
    ENGINE_RIGHT_PANEL: "RIGHT PANEL",
    ENGINE_BOTTOM_PANEL: "BOTTOM PANEL",
    ENGINE_CANVAS_COLOR: "black",
    ENGINE_BACKGROUND_COLOR: "darkgreen",
    ENGINE_CANVAS_ERROR: "your web browser does not support the <canvas> tag",
    IMAGE_PATH: "",
    SPRITE_DEFAULT_CONFIG: {
      x: 0,
      y: 0,
      z: 0,
      a: 0,
      dx: 0,
      dy: 0,
      dz: 0,
      da: 0,
      ddx: 0,
      ddy: 0,
      ddz: 0,
      dda: 0,
      width: 64,
      height: 64,
      imageFile: "",
      visible: true,
      boundAction: "WRAP"
    },
    SOUND_PATH: "",
    SOUND_DEFAULT_URL: "",
    TIMER_START_ON_CONSTRUCTION: true,
    BUTTON_DEFAULT_LABEL: "Launch the Missiles!",
    TEXTBOX_DEFAULT_TEXT: "This is a TextBox",
    TEXTBOX_DEFAULT_ALIGN: "center",
    TEXTBOX_DEFAULT_WIDTH: 50,
    TEXTBOX_DEFAULT_HEIGHT: 50,
    TEXTBOX_DEFAULT_X: 25,
    TEXTBOX_DEFAULT_Y: 25,
    TEXTBOX_DEFAULT_Z: -1,
    TEXTBOX_BACKGROUND_COLOR: "black",
    TEXTBOX_BACKGROUND_ALPHA: 1.0,
    TEXTBOX_BACKGROUND_VISIBLE: true,
    TEXTBOX_BORDER_SIZE: 5,
    TEXTBOX_BORDER_COLOR: "white",
    TEXTBOX_BORDER_ALPHA: 1.0,
    TEXTBOX_BORDER_VISIBLE: true,
    TEXTBOX_FONT_NAME: "Arial",
    TEXTBOX_FONT_SIZE: 8,
    TEXTBOX_FONT_COLOR: "white",
    TEXTBOX_FONT_ALPHA: 1.0,
    TEXTBOX_MARGINS_TOP: 5,
    TEXTBOX_MARGINS_BOTTOM: 5,
    TEXTBOX_MARGINS_RIGHT: 5,
    TEXTBOX_MARGINS_LEFT: 5
  };

  makeSortRule = function(sortBy, order) {
    if (order === "ascending") {
      return function(sp1, sp2) {
        return sp1.get(sortBy) - sp2.get(sortBy);
      };
    } else if (order === "decending") {
      return function(sp1, sp2) {
        return sp2.get(sortBy) - sp1.get(sortBy);
      };
    } else {
      throw new _GameError("order must be ascending or decending");
    }
  };

  game.KEYS = {
    LEFT: 37,
    RIGHT: 39,
    UP: 38,
    DOWN: 40,
    SPACE: 32,
    ESC: 27,
    PGUP: 33,
    PGDOWN: 34,
    HOME: 36,
    END: 35,
    _0: 48,
    _1: 49,
    _2: 50,
    _3: 51,
    _4: 52,
    _5: 53,
    _6: 54,
    _7: 55,
    _8: 56,
    _9: 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90
  };

  game.BOUND_ACTIONS = {
    WRAP: 0,
    BOUNCE: 1,
    SEMIBOUNCE: 2,
    STOP: 3,
    DIE: 4,
    CONTINUE: 5
  };

  game.keysDown = (function() {
    var _i, _len, _ref, _results;
    _ref = new Array(256);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      _results.push(key = false);
    }
    return _results;
  })();

  document.onkeydown = function(e) {
    e.preventDefault();
    return keysDown[e.keyCode] = true;
  };

  document.onkeyup = function(e) {
    e.preventDefault();
    return keysDown[e.keyCode] = false;
  };

  document.onmousemove = function(e) {
    this.mouseX = e.pageX;
    return this.mouseY = e.pageY;
  };

  _webkitAudioContext = typeof webkitAudioContext === "function" ? new webkitAudioContext() : void 0;

  _masterID = null;

  _masterUpdate = function() {
    Greenhorn.clear();
    if (typeof update === "function") {
      update();
    }
    return Sprites._updateAll();
  };

  _GameError = (function(_super) {
    __extends(_GameError, _super);

    function _GameError(message) {
      this.message = message;
      this.name = "GameError";
      console.log(this.message);
      return this;
    }

    _GameError.prototype.getName = function() {
      return this.name;
    };

    _GameError.prototype.getMessage = function() {
      return this.message;
    };

    _GameError.prototype.setMessage = function(message) {
      this.message = message;
    };

    return _GameError;

  })(Error);

  game.Greenhorn = (function() {
    function Greenhorn() {}

    Greenhorn._elmnts = {
      main: document.createElement("div"),
      title: document.createElement("h2"),
      leftPanel: document.createElement("div"),
      canvas: document.createElement("canvas"),
      rightPanel: document.createElement("div"),
      bottomPanel: document.createElement("div")
    };

    Greenhorn._elmnts.main.appendChild(Greenhorn._elmnts.title);

    Greenhorn._elmnts.main.appendChild(Greenhorn._elmnts.leftPanel);

    Greenhorn._elmnts.main.appendChild(Greenhorn._elmnts.canvas);

    Greenhorn._elmnts.main.appendChild(Greenhorn._elmnts.rightPanel);

    Greenhorn._elmnts.main.appendChild(Greenhorn._elmnts.bottomPanel);

    Greenhorn.getMouseX = function() {
      return document.mouseX - this.get("main", "offsetLeft") - this.get("canvas", "offsetLeft") - this.get("canvas", "width") / 2;
    };

    Greenhorn.getMouseY = function() {
      return document.mouseY - this.get("main", "offsetTop") - this.get("canvas", "offsetTop") - this.get("canvas", "height") / 2;
    };

    Greenhorn.get = function(elmnt, attr) {
      if (attr) {
        return this._elmnts[elmnt][attr];
      } else {
        return this._elmnts[elmnt];
      }
    };

    Greenhorn.set = function(elmnt, attr, what) {
      var value, _results;
      if (Object.prototype.toString.call(what) === '[object Object]') {
        _results = [];
        for (key in what) {
          value = what[key];
          _results.push(this._elmnts[elmnt][attr][key] = value);
        }
        return _results;
      } else {
        return this._elmnts[elmnt][attr] = what;
      }
    };

    Greenhorn.addButton = function(where, label, style, whenClicked) {
      var button, value;
      if (label == null) {
        label = env.BUTTON_DEFAULT_LABEL;
      }
      if (style == null) {
        style = {};
      }
      if (whenClicked == null) {
        whenClicked = (function(_this) {
          return function() {};
        })(this);
      }
      button = document.createElement("button");
      button.setAttribute("type", "button");
      button.innerHTML = label;
      for (key in style) {
        value = style[key];
        button.style[key] = value;
      }
      button.onclick = whenClicked;
      return this._elmnts[where].appendChild(button);
    };

    Greenhorn.start = function() {
      var bottomPanelStyle, canvasStyle, correctHeight, correctWidth, leftPanelStyle, mainStyle, rightPanelStyle, titleStyle;
      document.body.bgColor = env.BODY_BACKGROUND_COLOR;
      document.body.appendChild(this._elmnts.main);
      mainStyle = {
        width: "100%",
        display: "inline-block",
        backgroundColor: env.ENGINE_BACKGROUND_COLOR
      };
      titleStyle = {
        textAlign: "center",
        cssFloat: "left",
        display: "initial",
        marginTop: "1%",
        marginBottom: "1%",
        backgroundColor: "inherit",
        minWidth: "100%",
        minHeight: "6%",
        maxWidth: "100%",
        maxHeight: "6%"
      };
      leftPanelStyle = {
        minWidth: "15%",
        minHeight: "80%",
        maxWidth: "15%",
        maxHeight: "80%",
        cssFloat: "left",
        display: "initial",
        marginLeft: "1%",
        marginRight: "1%",
        overflow: "auto",
        whiteSpace: "pre",
        backgroundColor: "inherit"
      };
      canvasStyle = {
        minWidth: "66%",
        minHeight: "80%",
        maxWidth: "66%",
        maxHeight: "80%",
        display: "initial",
        cssFloat: "left",
        backgroundColor: env.ENGINE_CANVAS_COLOR
      };
      rightPanelStyle = {
        minWidth: "15%",
        minHeight: "80%",
        maxWidth: "15%",
        maxHeight: "80%",
        display: "initial",
        cssFloat: "left",
        marginLeft: "1%",
        marginRight: "1%",
        overflow: "auto",
        whiteSpace: "pre",
        backgroundColor: "inherit"
      };
      bottomPanelStyle = {
        minWidth: "100%",
        minHeight: "10%",
        maxWidth: "100%",
        maxHeight: "10%",
        display: "initial",
        textAlign: "center",
        cssFloat: "left",
        marginTop: "1%",
        marginBottom: "1%",
        backgroundColor: "inherit"
      };
      this.set("main", "style", mainStyle);
      this.set("title", "style", titleStyle);
      this.set("leftPanel", "style", leftPanelStyle);
      this.set("canvas", "style", canvasStyle);
      this.set("rightPanel", "style", rightPanelStyle);
      this.set("bottomPanel", "style", bottomPanelStyle);
      correctWidth = this.get("canvas", "offsetWidth");
      correctHeight = this.get("canvas", "offsetHeight");
      this.set("canvas", "width", correctWidth);
      this.set("canvas", "height", correctHeight);
      this._elmnts.canvas.getContext("2d").translate(this.get("canvas", "width") / 2, this.get("canvas", "height") / 2);
      this.set("title", "innerHTML", env.ENGINE_TITLE);
      this.set("leftPanel", "innerHTML", env.ENGINE_LEFT_PANEL);
      this.set("rightPanel", "innerHTML", env.ENGINE_RIGHT_PANEL);
      this.set("bottomPanel", "innerHTML", env.ENGINE_BOTTOM_PANEL);
      this.set("canvas", "innerHTML", env.ENGINE_CANVAS_ERROR);
      _masterID = setInterval(_masterUpdate, Math.ceil(1000 / env.FRAME_RATE));
    };

    Greenhorn.stop = function() {
      return clearInterval(_masterID);
    };

    Greenhorn.clear = function() {
      return this._elmnts.canvas.getContext("2d").clearRect(-this.get("canvas", "width") / 2, -this.get("canvas", "height") / 2, this.get("canvas", "width"), this.get("canvas", "height"));
    };

    Greenhorn.hide = function() {
      return set("main", "style", {
        "display": "none"
      });
    };

    Greenhorn.show = function() {
      return set("main", "style", {
        "display": "inline-block"
      });
    };

    Greenhorn.hideCursor = function() {
      return set("canvas", "style", {
        "cursor": "none"
      });
    };

    Greenhorn.showCursor = function() {
      return set("canvas", "style", {
        "cursor": "default"
      });
    };

    return Greenhorn;

  })();

  game.Sprite = (function() {
    var _list, _sortRule;

    _list = [];

    _sortRule = makeSortRule("z", "ascending");

    Sprite.howMany = function() {
      return this._list.length;
    };

    Sprite._updateAll = function() {
      var sp, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = _list.length; _i < _len; _i++) {
        sp = _list[_i];
        _results.push(sp._update());
      }
      return _results;
    };

    Sprite.getAll = function() {
      var excep, sp, what, _i, _len, _ref, _results;
      what = arguments[0], excep = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _ref = this._list;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sp = _ref[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.get(what));
        }
      }
      return _results;
    };

    Sprite.setAll = function() {
      var excep, sp, to, what, _i, _len, _ref, _results;
      what = arguments[0], to = arguments[1], excep = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      _ref = this._list;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sp = _ref[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.set(what, to));
        }
      }
      return _results;
    };

    Sprite.changeAll = function() {
      var excep, sp, step, what, _i, _len, _ref, _results;
      what = arguments[0], step = arguments[1], excep = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      _ref = this._list;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sp = _ref[_i];
        if (__indexOf.call(excep, sp) < 0) {
          _results.push(sp.change(what, step));
        }
      }
      return _results;
    };

    function Sprite(config) {
      var forbidden, value, _i, _len, _ref;
      if (config == null) {
        config = {};
      }
      forbidden = ["display", "position", "motion", "acceleration", "config", "distance", "speed", "rate", "posAngle", "motAngle", "accAngle"];
      for (_i = 0, _len = forbidden.length; _i < _len; _i++) {
        key = forbidden[_i];
        if (config[key] != null) {
          throw new _GameError("" + key + " is a forbidden config value");
        }
      }
      this._dis = {};
      this._pos = {};
      this._mot = {};
      this._acc = {};
      this._borders = {};
      this._dis.context = Greenhorn._elmnts.canvas.getContext("2d");
      _ref = env.SPRITE_DEFAULT_CONFIG;
      for (key in _ref) {
        value = _ref[key];
        if (config[key] == null) {
          config[key] = value;
        }
      }
      _list.push(this);
      this.set("config", config);
    }

    Sprite.prototype.get = function(what) {
      switch (what) {
        case "display":
          return this._dis;
        case "position":
          return this._pos;
        case "motion":
          return this._mot;
        case "acceleration":
          return this._acc;
        case "borders":
          return this._borders;
        case "imageFile":
          return this._dis.image.src;
        case "width":
        case "height":
        case "visible":
        case "boundAction":
          return this._dis[what];
        case "x":
        case "y":
        case "z":
        case "a":
          return this._pos[what];
        case "dx":
        case "dy":
        case "dz":
        case "da":
          return this._mot[what];
        case "ddx":
        case "ddy":
        case "ddz":
        case "dda":
          return this._acc[what];
        case "top":
        case "bottom":
        case "right":
        case "left":
          return this._borders[what];
        case "distance":
          return Math.sqrt(Math.pow(this._pos.x, 2) + Math.pow(this._pos.y, 2));
        case "speed":
          return Math.sqrt(Math.pow(this._mot.dx, 2) + Math.pow(this._mot.dy, 2));
        case "rate":
          return Math.sqrt(Math.pow(this._acc.ddx, 2) + Math.pow(this._acc.ddy, 2));
        case "posAngle":
          return Math.atan2(this._pos.y, this._pos.x);
        case "motAngle":
          return Math.atan2(this._mot.dy, this._mot.dx);
        case "accAngle":
          return Math.atan2(this._acc.ddy, this._acc.ddx);
        default:
          throw new _GameError("" + what + " is not a get-able Sprite attribute");
      }
    };

    Sprite.prototype.set = function(what, to) {
      var k, proxy, v, _base;
      switch (what) {
        case "display":
        case "position":
        case "motion":
        case "acceleration":
        case "config":
          for (k in to) {
            v = to[k];
            this.set(k, v);
          }
          break;
        case "imageFile":
          if ((_base = this._dis).image == null) {
            _base.image = new Image();
          }
          this._dis.image.src = env.IMAGE_PATH.concat(to);
          break;
        case "boundAction":
          this._dis.boundAction = BOUND_ACTIONS[to];
          break;
        case "width":
        case "height":
        case "visible":
          this._dis[what] = to;
          if (what === "width" || what === "height") {
            this._calcBorders();
          }
          break;
        case "x":
        case "y":
        case "z":
        case "a":
          this._pos[what] = to;
          if (what === "x" || what === "y") {
            this._calcBorders();
          }
          if (what === "z") {
            _list.sort(_sortRule);
          }
          break;
        case "dx":
        case "dy":
        case "dz":
        case "da":
          this._mot[what] = to;
          break;
        case "ddx":
        case "ddy":
        case "ddz":
        case "dda":
          this._acc[what] = to;
          break;
        case "distance":
          proxy = {
            x: to * Math.cos(this.get("posAngle")),
            y: to * Math.sin(this.get("posAngle"))
          };
          this.set("position", proxy);
          break;
        case "speed":
          proxy = {
            dx: to * Math.cos(this.get("motAngle")),
            dy: to * Math.sin(this.get("motAngle"))
          };
          this.set("motion", proxy);
          break;
        case "rate":
          proxy = {
            ddx: to * Math.cos(this.get("accAngle")),
            ddy: to * Math.sin(this.get("accAngle"))
          };
          this.set("acceleration", proxy);
          break;
        case "posAngle":
          proxy = {
            x: this.get("distance") * Math.cos(to),
            y: this.get("distance") * Math.sin(to)
          };
          this.set("position", proxy);
          break;
        case "motAngle":
          proxy = {
            dx: this.get("speed") * Math.cos(to),
            dy: this.get("speed") * Math.sin(to)
          };
          this.set("motion", proxy);
          break;
        case "accAngle":
          proxy = {
            ddx: this.get("rate") * Math.cos(to),
            ddy: this.get("rate") * Math.sin(to)
          };
          this.set("acceleration", proxy);
          break;
        default:
          throw new _GameError("" + what + " is not a set-able Sprite attribute");
      }
      return this;
    };

    Sprite.prototype.change = function(what, step) {
      var k, proxy, v;
      switch (what) {
        case "display":
        case "position":
        case "motion":
        case "acceleration":
          for (k in step) {
            v = step[k];
            this.change(k.slice(1), v);
          }
          break;
        case "width":
        case "height":
          this._dis[what] += step;
          this._calcBorders();
          break;
        case "x":
        case "y":
        case "z":
        case "a":
          this._pos[what] += step / env.FRAME_RATE;
          if (what === "x" || what === "y") {
            this._calcBorders();
          }
          if (what === "z") {
            _list.sort(_sortRule);
          }
          break;
        case "dx":
        case "dy":
        case "dz":
        case "da":
          this._mot[what] += step / env.FRAME_RATE;
          break;
        case "ddx":
        case "ddy":
        case "ddz":
        case "dda":
          this._acc[what] += step / env.FRAME_RATE;
          break;
        case "distance":
          proxy = {
            dx: step * Math.cos(this.get("posAngle")),
            dy: step * Math.sin(this.get("posAngle"))
          };
          this.change("position", proxy);
          break;
        case "speed":
          proxy = {
            ddx: step * Math.cos(this.get("motAngle")),
            ddy: step * Math.sin(this.get("motAngle"))
          };
          this.change("motion", proxy);
          break;
        case "rate":
          proxy = {
            dddx: step * Math.cos(this.get("accAngle")),
            dddy: step * Math.sin(this.get("accAngle"))
          };
          this.change("acceleration", proxy);
          break;
        case "posAngle":
          proxy = {
            dx: this.get("distance") * Math.cos(step),
            dy: this.get("distance") * Math.sin(step)
          };
          this.change("position", proxy);
          break;
        case "motAngle":
          proxy = {
            ddx: this.get("speed") * Math.cos(step),
            ddy: this.get("speed") * Math.sin(step)
          };
          this.change("motion", proxy);
          break;
        case "accAngle":
          proxy = {
            dddx: this.get("rate") * Math.cos(step),
            dddy: this.get("rate") * Math.sin(step)
          };
          this.change("acceleration", proxy);
          break;
        default:
          throw new _GameError("" + what + " is not a change-able Sprite attribute");
      }
      return this;
    };

    Sprite.prototype.collidesWith = function(other) {
      var collision;
      collision = true;
      if (this._dis.visible && other._dis.visible && this._pos.z === other.get("z")) {
        if (this._borders.bottom > other._borders.top || this._borders.top < other._borders.bottom || this._borders.right < other._borders.left || this._borders.left > other._borders.right) {
          collision = false;
        }
      } else {
        collision = false;
      }
      return collision;
    };

    Sprite.prototype.collidesWithMouse = function() {
      var collision, _ref, _ref1;
      collision = false;
      if (this._dis.visible) {
        if ((this._borders.left < (_ref = Greenhorn.getMouseX()) && _ref < this._borders.right) && (this._borders.bottom < (_ref1 = Greenhorn.getMouseY()) && _ref1 < this._borders.top)) {
          collision = true;
        }
      }
      return collision;
    };

    Sprite.prototype.distanceTo = function(other) {
      return Math.sqrt(Math.pow(this._pos.x - other.get("x"), 2) + Math.pow(this._pos.y - other.get("y"), 2));
    };

    Sprite.prototype.distanceToMouse = function() {
      return Math.sqrt(Math.pow(this._pos.x - Greenhorn.getMouseX(), 2) + Math.pow(this._pos.y - Greenhorn.getMouseY(), 2));
    };

    Sprite.prototype.angleTo = function(other) {
      return -Math.atan2(other.get("y") - this._pos.y, other.get("x") - this._pos.x);
    };

    Sprite.prototype.angleToMouse = function() {
      return -Math.atan2(Greenhorn.getMouseY() - this._pos.y, Greenhorn.getMouseX() - this._pos.x);
    };

    Sprite.prototype._calcBorders = function() {
      this._borders.left = this._pos.x - this._dis.width / 2;
      this._borders.right = this._pos.x + this._dis.width / 2;
      this._borders.top = this._pos.y + this._dis.height / 2;
      return this._borders.bottom = this._pos.y - this._dis.height / 2;
    };

    Sprite.prototype._draw = function() {
      this._dis.context.save();
      this._dis.context.translate(this._pos.x, -this._pos.y);
      this._dis.context.rotate(this._pos.a);
      this._dis.context.drawImage(this._dis.image, 0 - this._dis.width / 2, 0 - this._dis.height / 2, this._dis.width, this._dis.height);
      return this._dis.context.restore();
    };

    Sprite.prototype._checkBounds = function() {
      var bounds, hitBottom, hitLeft, hitRight, hitTop, offBottom, offLeft, offRight, offTop;
      bounds = {
        top: Greenhorn.get("canvas", "height") / 2,
        left: -Greenhorn.get("canvas", "width") / 2,
        bottom: -Greenhorn.get("canvas", "height") / 2,
        right: Greenhorn.get("canvas", "width") / 2
      };
      offLeft = this._borders.right < bounds.left;
      offTop = this._borders.bottom > bounds.top;
      offRight = this._borders.left > bounds.right;
      offBottom = this._borders.top < bounds.bottom;
      hitLeft = this._borders.left <= bounds.left;
      hitTop = this._borders.top >= bounds.top;
      hitRight = this._borders.right >= bounds.right;
      hitBottom = this._borders.bottom <= bounds.bottom;
      switch (this._dis.boundAction) {
        case BOUND_ACTIONS.WRAP:
          if (offLeft) {
            this.set("x", bounds.right + this._dis.width / 2);
          }
          if (offTop) {
            this.set("y", bounds.bottom - this._dis.height / 2);
          }
          if (offRight) {
            this.set("x", bounds.left - this._dis.width / 2);
          }
          if (offBottom) {
            this.set("y", bounds.top + this._dis.height / 2);
          }
          break;
        case BOUND_ACTIONS.BOUNCE:
          if (hitTop) {
            this.set("y", bounds.top - this._dis.height / 2);
            this._mot.dy *= -1;
          }
          if (hitBottom) {
            this.set("y", bounds.bottom + this._dis.height / 2);
            this._mot.dy *= -1;
          }
          if (hitLeft) {
            this.set("x", bounds.left + this._dis.width / 2);
            this._mot.dx *= -1;
          }
          if (hitRight) {
            this.set("x", bounds.right - this._dis.width / 2);
            this._mot.dx *= -1;
          }
          break;
        case BOUND_ACTIONS.SEMIBOUNCE:
          if (hitTop) {
            this.set("y", bounds.top - this._dis.height / 2);
            this._mot.dy *= -.75;
          }
          if (hitBottom) {
            this.set("y", bounds.bottom + this._dis.height / 2);
            this._mot.dy *= -.75;
          }
          if (hitLeft) {
            this.set("x", bounds.left + this._dis.width / 2);
            this._mot.dx *= -.75;
          }
          if (hitRight) {
            this.set("x", bounds.right - this._dis.width / 2);
            this._mot.dx *= -.75;
          }
          break;
        case BOUND_ACTIONS.STOP:
          if (hitLeft || hitTop || hitRight || hitBottom) {
            this._mot.dx = 0;
            this._mot.dy = 0;
            this._acc.ddx = 0;
            this._acc.ddy = 0;
            if (hitTop) {
              this.set("y", bounds.top - this._dis.height / 2);
            }
            if (hitBottom) {
              this.set("y", bounds.bottom + this._dis.height / 2);
            }
            if (hitLeft) {
              this.set("x", bounds.left + this._dis.width / 2);
            }
            if (hitRight) {
              this.set("x", bounds.right - this._dis.width / 2);
            }
          }
          break;
        case BOUND_ACTIONS.DIE:
          if (offLeft || offTop || offRight || offBottom) {
            this._dis.visible = false;
          }
      }
      return this._dis.boundAction;
    };

    Sprite.prototype._update = function() {
      if (this._dis.visible) {
        this.change("motion", this._acc);
        this.change("position", this._mot);
        this._checkBounds();
        this._draw();
      }
      return this;
    };

    Sprite.prototype.report = function() {
      return "display:\n    width: " + this._dis.width + "\n    height: " + this._dis.height + "\n    visible: " + this._dis.visible + "\n    boundAction: " + this._dis.boundAction + "\nposition:\n    x: " + (this._pos.x.toFixed(3)) + "\n    y: " + (this._pos.y.toFixed(3)) + "\n    z: " + (this._pos.z.toFixed(3)) + "\n    a: " + (this._pos.a.toFixed(3)) + "\nmotion:\n    dx: " + (this._mot.dx.toFixed(3)) + "\n    dy: " + (this._mot.dy.toFixed(3)) + "\n    dz: " + (this._mot.dz.toFixed(3)) + "\n    da: " + (this._mot.da.toFixed(3)) + "\nacceleration:\n    ddx: " + (this._acc.ddx.toFixed(3)) + "\n    ddy: " + (this._acc.ddy.toFixed(3)) + "\n    ddz: " + (this._acc.ddz.toFixed(3)) + "\n    dda: " + (this._acc.dda.toFixed(3));
    };

    Sprite.prototype.log = function() {
      if (typeof console !== "undefined" && console !== null) {
        console.log(this.report());
      }
    };

    return Sprite;

  })();

  game.Sprites = game.Sprite;

  game.Sound = (function() {
    function Sound(url) {
      var mp3_src, ogg_src, request, wav_src;
      if (url == null) {
        url = env.SOUND_DEFAULT_URL;
      }
      this._url = env.SOUND_PATH.concat(url);
      if (typeof webkitAudioContext !== "undefined" && webkitAudioContext !== null) {
        this._source = _webkitAudioContext.createBufferSource();
        this._gainNode = _webkitAudioContext.createGainNode();
        request = new XMLHttpRequest();
        request.responseType = 'arraybuffer';
        request.open('GET', this._url, true);
        request.successCallback = (function(_this) {
          return function(buffer) {
            _this._source.buffer = buffer;
            _this._source.connect(_this._gainNode);
            _this._gainNode.connect(_webkitAudioContext.destination);
          };
        })(this);
        request.failureCallback = function() {
          throw new _GameError("Webkit Sound Error");
        };
        request.onload = function() {
          return _webkitAudioContext.decodeAudioData(this.response, this.successCallback, this.failureCallback);
        };
        request.send();
      } else {
        this._audio = document.createElement('audio');
        this._audio.setAttribute('controls', 'none');
        this._audio.style.display = 'none';
        mp3_src = document.createElement('source');
        ogg_src = document.createElement('source');
        wav_src = document.createElement('source');
        mp3_src.type = 'audio/mpeg';
        ogg_src.type = 'audio/ogg';
        wav_src.type = 'audio/wav';
        if (this._url.indexOf('.mp3') !== -1) {
          mp3_src.src = this._url;
          ogg_src.src = this._url.replace('.mp3', '.ogg');
          wav_src.src = this._url.replace('.mp3', '.wav');
        } else if (this._url.indexOf('.ogg') !== -1) {
          ogg_src.src = this._url;
          mp3_src.src = this._url.replace('.ogg', '.mp3');
          wav_src.src = this._url.replace('.ogg', '.wav');
        } else if (this._url.indexOf('.wav') !== -1) {
          wav_src.src = this._url;
          mp3_src.src = this._url.replace('.wav', '.mp3');
          ogg_src.src = this._url.replace('.wav', '.ogg');
        } else {
          throw new _GameError("Sound url must be .mp3, .ogg, or .wav extension");
        }
        this._audio.appendChild(mp3_src);
        this._audio.appendChild(ogg_src);
        this._audio.appendChild(wav_src);
        Greenhorn._elmnts.canvas.appendChild(this._audio);
      }
      return;
    }

    Sound.prototype.play = function(opt) {
      if (opt == null) {
        opt = {};
      }
      if (typeof webkitAudioContext !== "undefined" && webkitAudioContext !== null) {
        if (opt.gainValue != null) {
          this._gainNode.gain.value = opt.gainValue;
        }
        if (opt.loop != null) {
          this._source.loop = opt.loop;
        }
        this._source.start(0);
      } else {
        if (opt.loop != null) {
          this._audio.loop = opt.loop;
        }
        this._audio.play();
      }
    };

    Sound.prototype.stop = function() {
      if (typeof webkitAudioContext !== "undefined" && webkitAudioContext !== null) {
        this._source.stop(0);
      } else {
        this._audio.pause();
        this._audio.currentTime = 0;
      }
    };

    return Sound;

  })();

  game.Timer = (function() {
    function Timer(start_now) {
      if (start_now == null) {
        start_now = env.TIMER_START_ON_CONSTRUCTION;
      }
      this._elapsedTime = 0;
      this._startTime = start_now ? this.getCurrentTime() : null;
      return this;
    }

    Timer.prototype.getStartTime = function() {
      return this._startTime;
    };

    Timer.prototype.getCurrentTime = function() {
      return (new Date()).getTime();
    };

    Timer.prototype.getElapsedTime = function() {
      if (!this._startTime) {
        return this._elapsedTime;
      } else {
        return this._elapsedTime + this.getCurrentTime() - this._startTime;
      }
    };

    Timer.prototype.start = function() {
      if (!this._startTime) {
        this._startTime = this.getCurrentTime();
      }
    };

    Timer.prototype.pause = function() {
      if (this._startTime) {
        this._elapsedTime += this.getCurrentTime() - this.getStartTime();
        this._startTime = null;
      }
    };

    Timer.prototype.restart = function() {
      this._elapsedTime = 0;
      this._startTime = this.getCurrentTime();
    };

    Timer.prototype.stop = function() {
      this._elapsedTime = 0;
      this._startTime = null;
    };

    return Timer;

  })();

  game.Button = (function() {
    function Button(label) {
      if (label == null) {
        label = env.BUTTON_DEFAULT_LABEL;
      }
      this._clicked = false;
      this._button = document.createElement("button");
      this._button.innerHTML = label;
      this._button.setAttribute("type", "button");
      this._button.onmousedown = (function(_this) {
        return function() {
          _this._clicked = true;
        };
      })(this);
      this._button.onmouseup = (function(_this) {
        return function() {
          _this._clicked = false;
        };
      })(this);
      document.body.appendChild(this._button);
      return this;
    }

    Button.prototype.isClicked = function() {
      return this._clicked;
    };

    return Button;

  })();

  game.TextBox = (function(_super) {
    __extends(TextBox, _super);

    function TextBox(text, config) {
      var _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      if (text == null) {
        text = env.TEXTBOX_DEFAULT_TEXT;
      }
      if (config == null) {
        config = {};
      }
      config.imageFile = "";
      if (config.width == null) {
        config.width = env.TEXTBOX_DEFAULT_WIDTH;
      }
      if (config.height == null) {
        config.height = env.TEXTBOX_DEFAULT_HEIGHT;
      }
      if (config.x == null) {
        config.x = env.TEXTBOX_DEFAULT_X;
      }
      if (config.y == null) {
        config.y = env.TEXTBOX_DEFAULT_Y;
      }
      if (config.z == null) {
        config.z = env.TEXTBOX_DEFAULT_Z;
      }
      TextBox.__super__.constructor.call(this, config);
      this._text = text.split('\n');
      this._background = {
        color: (_ref = config.backgroundColor) != null ? _ref : env.TEXTBOX_BACKGROUND_COLOR,
        alpha: (_ref1 = config.backgroundAlpah) != null ? _ref1 : env.TEXTBOX_BACKGROUND_ALPHA,
        visible: (_ref2 = config.backgroundVisible) != null ? _ref2 : env.TEXTBOX_BACKGROUND_VISIBLE
      };
      this._border = {
        size: (_ref3 = config.borderSize) != null ? _ref3 : env.TEXTBOX_BORDER_SIZE,
        color: (_ref4 = config.borderColor) != null ? _ref4 : env.TEXTBOX_BORDER_COLOR,
        alpha: (_ref5 = config.borderAlpha) != null ? _ref5 : env.TEXTBOX_BORDER_ALPHA,
        visible: (_ref6 = config.borderVisible) != null ? _ref6 : env.TEXTBOX_BORDER_VISIBLE
      };
      this._font = {
        name: (_ref7 = config.fontName) != null ? _ref7 : env.TEXTBOX_FONT_NAME,
        size: (_ref8 = config.fontSize) != null ? _ref8 : env.TEXTBOX_FONT_SIZE,
        color: (_ref9 = config.fontColor) != null ? _ref9 : env.TEXTBOX_FONT_COLOR,
        alpha: (_ref10 = config.fontAlpha) != null ? _ref10 : env.TEXTBOX_FONT_ALPHA
      };
      this._margins = {
        top: (_ref11 = config.marginsTop) != null ? _ref11 : env.TEXTBOX_MARGINS_TOP,
        bottom: (_ref12 = config.marginsBottom) != null ? _ref12 : env.TEXTBOX_MARGINS_BOTTOM,
        right: (_ref13 = config.marginsRight) != null ? _ref13 : env.TEXTBOX_MARGINS_RIGHT,
        left: (_ref14 = config.marginsLeft) != null ? _ref14 : env.TEXTBOX_MARGINS_LEFT
      };
      this._dis.context.textAlign = (_ref15 = config.textAlign) != null ? _ref15 : env.TEXTBOX_DEFAULT_ALIGN;
      this._fitText();
      return this;
    }

    TextBox.prototype.getText = function() {
      return this._text.join('\n');
    };

    TextBox.prototype.getAlign = function() {
      return this._dis.context.textAlign;
    };

    TextBox.prototype.getBackground = function() {
      return this._background;
    };

    TextBox.prototype.getBorder = function() {
      return this._border;
    };

    TextBox.prototype.getFont = function() {
      return this._font;
    };

    TextBox.prototype.getMargins = function() {
      return this._margins;
    };

    TextBox.prototype.setText = function(new_text) {
      this._text = new_text.split('\n');
      this._fitText();
    };

    TextBox.prototype.setAlign = function(new_align) {
      this._dis.context.textAlign = new_align;
    };

    TextBox.prototype.setBackground = function(new_background) {
      this._background.color = new_background.color != null;
      this._background.alpha = new_background.alpha != null;
      this._background.visible = new_background.visible != null;
    };

    TextBox.prototype.setBorder = function(new_border) {
      this._border.size = new_border.size != null;
      this._border.color = new_border.color != null;
      this._border.alpha = new_border.alpha != null;
      this._border.visible = new_border.visible != null;
      this._fitText();
    };

    TextBox.prototype.setFont = function(new_font) {
      this._font.name = new_font.name != null;
      this._font.size = new_font.size != null;
      this._font.color = new_font.color != null;
      this._font.alpha = new_font.alpha != null;
      this._fitText();
    };

    TextBox.prototype.setMargins = function(new_margins) {
      this._margins.top = new_margins.top != null;
      this._margins.bottom = new_margins.bottom != null;
      this._margins.right = new_margins.right != null;
      this._margins.left = new_margins.left != null;
      this._fitText();
    };

    TextBox.prototype.showBackground = function() {
      this._background.visible = true;
    };

    TextBox.prototype.hideBackground = function() {
      this._background.visible = false;
    };

    TextBox.prototype.showBorder = function() {
      this._border.visible = true;
      this._fitText();
    };

    TextBox.prototype.hideBorder = function() {
      this._border.visible = false;
      this._fitText();
    };

    TextBox.prototype._fitText = function() {
      var len, line, old_height, old_width, _i, _len, _ref;
      old_width = this._dis.width;
      old_height = this._dis.height;
      this._dis.width = 0;
      this._dis.height = (this._font.size * this._text.length) + ((Math.floor(this._font.size / 3)) * (this._text.length - 1));
      _ref = this._text;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        len = this._dis.context.measureText(line.width);
        if (this._dis.width < len) {
          this._dis.width = len;
        }
      }
      this._dis.width += this._margins.left + this._margins.right;
      this._dis.height += this._margins.top + this._margins.bottom;
      if (this._border.visible) {
        this._dis.width += 2 * this._border.size;
        this._dis.height += 2 * this._border.size;
      }
      if (this._dis.width < old_width) {
        this.changeXby(-Math.abs(this._dis.width - old_width) / 2);
      } else {
        this.changeXby(Math.abs(this._dis.width - old_width) / 2);
      }
      if (this._dis.height < old_height) {
        this.changeYby(-Math.abs(this._dis.height - old_height) / 2);
      } else {
        this.changeYby(Math.abs(this._dis.height - old_height) / 2);
      }
    };

    TextBox.prototype._writeText = function() {
      var i, line, xOffset, yOffset, _i, _len, _ref;
      xOffset = this._margins.left;
      yOffset = this._margins.top;
      if (this._border.visible) {
        xOffset += this._border.size;
        yOffset += this._border.size;
      }
      this._dis.context._font = "" + this._font.size + "px " + this._font.name;
      this._dis.context.fillStyle = this._font.color;
      this._dis.context.globalAlpha = this._font.alpha;
      if (this._text.length > 1) {
        _ref = this._text;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          line = _ref[i];
          this._dis.context.fillText(line, this._pos.x + xOffset - (this._dis.width / 2), this._pos.y + yOffset - (this._dis.height / 2) + (this._font.size * i) + (i !== 0 ? Math.floor(this._font.size / 3) : void 0));
        }
      } else {
        this._dis.context.fillText(this._text[0], this._pos.x + xOffset - (this._dis.width / 2), this._pos.y + yOffset - (this._dis.height / 2));
      }
    };

    TextBox.prototype._draw = function() {
      this._dis.context.save();
      if (this._background.visible) {
        this._dis.context.fillStyle = this._background.color;
        this._dis.context.globalAlpha = this._background.alpha;
        this._dis.context.fillRect(this._pos.x - this._dis.width / 2, this._pos.y - this._dis.height / 2, this._dis.width, this._dis.height);
      }
      if (this._border.visible) {
        this._dis.context.strokeStyle = this._border.color;
        this._dis.context.lineWidth = this._border.size;
        this._dis.context.globalAlpha = this._border.alpha;
        this._dis.context.strokeRect(this._pos.x - (this._dis.width / 2), this._pos.y - (this._dis.height / 2), this._dis.width, this._dis.height);
      }
      this._writeText();
      this._dis.context.restore();
    };

    return TextBox;

  })(Sprite);

}).call(this);
